"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[9015],{59824(e,t,n){n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"feature-descriptions","title":"Feature Glossary","description":"As explained in the features section of the models wiki, a feature can be used to tag a flow and help filtering issues. A feature describes a property of a flow. A feature can be any arbitrary string. A feature that\'s prefixed with always- signals that every path in the issue has that feature associated with it, while lacking that prefix means that at least one path, but not all paths, contains that feature.","source":"@site/documentation/feature_descriptions.md","sourceDirName":".","slug":"/feature-descriptions","permalink":"/docs/feature-descriptions","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/mariana-trench/tree/main/documentation/website/documentation/feature_descriptions.md","tags":[],"version":"current","frontMatter":{"id":"feature-descriptions","title":"Feature Glossary","sidebar_label":"Feature Glossary"},"sidebar":"docs","previous":{"title":"Android/API Lifecycles","permalink":"/docs/android-lifecycles"},"next":{"title":"Build from Source","permalink":"/docs/build-from-source"}}');var i=n(74848),s=n(28453);const r={id:"feature-descriptions",title:"Feature Glossary",sidebar_label:"Feature Glossary"},o=void 0,l={},c=[{value:"Pre-configured features",id:"pre-configured-features",level:2}];function d(e){const t={a:"a",code:"code",h2:"h2",li:"li",p:"p",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.p,{children:["As explained in the ",(0,i.jsx)(t.a,{href:"../models/#features",children:"features section of the models wiki"}),", a feature can be used to tag a flow and help filtering issues. A feature describes a property of a flow. A feature can be any arbitrary string. A feature that's prefixed with ",(0,i.jsx)(t.code,{children:"always-"})," signals that every path in the issue has that feature associated with it, while lacking that prefix means that at least one path, but not all paths, contains that feature."]}),"\n",(0,i.jsx)(t.p,{children:"This page will cover the purpose of the pre-configured features to help you understand how you can use them best."}),"\n",(0,i.jsx)(t.h2,{id:"pre-configured-features",children:"Pre-configured features"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["via-caller-exported","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["This feature is applied when the root callable is directly or indirectly called from an exported component defined in the Android manifest. For example, if the root callable is in the ",(0,i.jsx)(t.code,{children:"MainActivity"})," and the ",(0,i.jsx)(t.code,{children:"MainActivity"})," is exported, this feature will be attached. It is needed in order to determine if an ",(0,i.jsx)(t.code,{children:"Intent"})," source is third-party controllable or not. This feature is sometimes accompanied by ",(0,i.jsx)(t.code,{children:"via-class"})," which tells you which class Mariana Trench used to determine that the root callable is called from an exported class."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["via-caller-unexported","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Same as ",(0,i.jsx)(t.code,{children:"via-caller-exported"})," but applied if the root callable is considered to be called only via unexported components"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["via-caller-permission","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Similair to ",(0,i.jsx)(t.code,{children:"via-caller-exported"})," but applied if the root callable paths to a manifest entry that has a protectionLevel or Android permission declared."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["via-explicit-intent","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Applied when the taint flow goes via a class or package name setter on an Intent. This can be used to infer whether a launched Intent can resolve to third party apps or only to a specifically defined app (implicit versus explicit intents)."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["via-inner-class-this","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Anonymous classes in Java byte code transfer the taint from the parent class to the anonymous class via ",(0,i.jsx)(t.code,{children:"this.this$0"})," which can lead to ",(0,i.jsx)(t.a,{href:"../models/#taint-broadening",children:"broaden false positives"}),". This feature can be used to filter out such flows when they are a common false positive pattern."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["cast:[...]","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Cast features such as ",(0,i.jsx)(t.code,{children:"cast:boolean"})," are applied when the tainted data is converted to that specific type. This allows for example to filter out data flows such as ",(0,i.jsx)(t.code,{children:"taintedString.length()"})," where the returned tainted integer may no longer be of interest."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["via-obscure","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Obscure methods are methods for which Mariana Trench doesn't have any byte code available. Therefore we generally apply taint-in-taint-out behaviour on these methods and add the feature ",(0,i.jsx)(t.code,{children:"via-obscure"})," to tell the user that the data flow went along an obscure method."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["via-[...]-broadening","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Is applied when any of the four broaden operations is applied (see ",(0,i.jsx)(t.a,{href:"../models/#taint-broadening",children:"Models"}),")."]}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453(e,t,n){n.d(t,{R:()=>r,x:()=>o});var a=n(96540);const i={},s=a.createContext(i);function r(e){const t=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(s.Provider,{value:t},e.children)}}}]);
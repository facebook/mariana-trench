"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[1414],{64252(e,n,t){t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"multi-source-sink-rules","title":"Multi-Source, Multi-Sink Rules","description":"Multi-Source, Multi-Sink Rules","source":"@site/documentation/multi_source_sink_rules.md","sourceDirName":".","slug":"/multi-source-sink-rules","permalink":"/docs/multi-source-sink-rules","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/mariana-trench/tree/main/documentation/website/documentation/multi_source_sink_rules.md","tags":[],"version":"current","frontMatter":{"id":"multi-source-sink-rules","title":"Multi-Source, Multi-Sink Rules","sidebar_label":"Multi-Source, Multi-Sink Rules"}}');var s=t(74848),l=t(28453);const r={id:"multi-source-sink-rules",title:"Multi-Source, Multi-Sink Rules",sidebar_label:"Multi-Source, Multi-Sink Rules"},o=void 0,u={},a=[{value:"Multi-Source, Multi-Sink Rules",id:"multi-source-multi-sink-rules",level:3}];function c(e){const n={a:"a",blockquote:"blockquote",code:"code",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h3,{id:"multi-source-multi-sink-rules",children:"Multi-Source, Multi-Sink Rules"}),"\n",(0,s.jsx)(n.p,{children:'Multi-source multi-sink rules are used to track the flow of taint from multiple sources to multiple sinks. This can, for example, be useful if you want to track both the source types "SensitiveData" and "WorldReadableFileLocation" to an IO operation as displayed in the code below.'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'File externalDir = context.getExternalFilesDir() // source WorldReadableFileLocation\nString sensitiveData = getUserToken() // source SensitiveData\n\nFile outputFile = new File(externalDir, "file.txt");\ntry (FileOutputStream fos = new FileOutputStream(outputFile)) {\n  fos.write(sensitiveData.getBytes()); // sink Argument(0) and Argument(1)\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Such a rule can be defined as follows:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Define the sources as usual (see documentation above)."}),"\n",(0,s.jsxs)(n.li,{children:["Define sinks on ",(0,s.jsx)(n.code,{children:"FileOutputStream::write"})," as follows:"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "model_generators": [\n    {\n      "find": "methods",\n      "where": [ /* name = write */ ... ],\n      "model": {\n        "sink": [\n          {\n            "kind": "PartialExternalFileWrite",\n            "partial_label": "outputStream",\n            "port": "Argument(0)"\n          },\n          {\n            "kind": "PartialExternalFileWrite",\n            "partial_label": "outputBytes",\n            "port": "Argument(1)"\n          }\n        ]\n      }\n    }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Here, there is ",(0,s.jsx)(n.strong,{children:"one sink"})," method catching ",(0,s.jsx)(n.strong,{children:"two sources"})," flowing into it, turning it into a ",(0,s.jsx)(n.strong,{children:"partial_sink"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["To define each source that flows into the ",(0,s.jsx)(n.code,{children:"partial_sink"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"kind"})," must be the same"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"partial_label"})," must be unique - this will map to the source in the rule definition"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"port"})," must be unique - see ",(0,s.jsx)(n.a,{href:"../models/#access-path-format",children:"port documentation"})]}),"\n",(0,s.jsxs)(n.li,{children:["There must be as many ",(0,s.jsx)(n.code,{children:"partial_labels"})," are there are ",(0,s.jsx)(n.code,{children:"multi_sources"})]}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"NOTE:"})," Multi-source/sink rules currently support exactly 2 sources/sinks only."]}),"\n"]}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsx)(n.li,{children:"Define rules as follows:"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'  {\n    "name": "Experimental: Some name",\n    "code": 9001,\n    "description": "More description here.",\n    "multi_sources": {\n      "outputBytes": [\n        "SensitiveData"\n      ],\n      "outputStream": [\n        "WorldReadableFileLocation"\n      ]\n    },\n    "partial_sinks": [\n      "PartialExternalFileWrite"\n    ]\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Pay attention to how the labels and partial sink kinds match what is defined in the sinks above."})]})}function d(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},28453(e,n,t){t.d(n,{R:()=>r,x:()=>o});var i=t(96540);const s={},l=i.createContext(s);function r(e){const n=i.useContext(l);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(l.Provider,{value:n},e.children)}}}]);
"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[848],{3905:(e,n,t)=>{t.r(n),t.d(n,{MDXContext:()=>c,MDXProvider:()=>p,mdx:()=>f,useMDXComponents:()=>u,withMDXComponents:()=>d});var o=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(){return a=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var o in t)Object.prototype.hasOwnProperty.call(t,o)&&(e[o]=t[o])}return e},a.apply(this,arguments)}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,o,r=function(e,n){if(null==e)return{};var t,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var c=o.createContext({}),d=function(e){return function(n){var t=u(n.components);return o.createElement(e,a({},n,{components:t}))}},u=function(e){var n=o.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},p=function(e){var n=u(e.components);return o.createElement(c.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},h=o.forwardRef((function(e,n){var t=e.components,r=e.mdxType,a=e.originalType,i=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=u(t),p=r,h=d["".concat(i,".").concat(p)]||d[p]||m[p]||a;return t?o.createElement(h,s(s({ref:n},c),{},{components:t})):o.createElement(h,s({ref:n},c))}));function f(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var a=t.length,i=new Array(a);i[0]=h;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var c=2;c<a;c++)i[c]=t[c];return o.createElement.apply(null,i)}return o.createElement.apply(null,t)}h.displayName="MDXCreateElement"},30947:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>i,metadata:()=>l,toc:()=>d});var o=t(87462),r=(t(67294),t(3905)),a=t(86341);const i={id:"known-false-negatives",title:"Known False Negatives",sidebar_label:"Known False Negatives"},s=void 0,l={unversionedId:"known-false-negatives",id:"known-false-negatives",title:"Known False Negatives",description:"Like any static analysis tools, Mariana Trench has false negatives. This documents the more well-known places where taint is dropped. Note that this is not an exhaustive list. See this wiki for instructions on how to debug them.",source:"@site/documentation/known_false_negatives.md",sourceDirName:".",slug:"/known-false-negatives",permalink:"/docs/known-false-negatives",draft:!1,editUrl:"https://github.com/facebook/mariana-trench/tree/main/documentation/website/documentation/known_false_negatives.md",tags:[],version:"current",frontMatter:{id:"known-false-negatives",title:"Known False Negatives",sidebar_label:"Known False Negatives"},sidebar:"docs",previous:{title:"Feature Glossary",permalink:"/docs/feature-descriptions"},next:{title:"Build from Source",permalink:"/docs/build-from-source"}},c={},d=[{value:"Trace too Long",id:"trace-too-long",level:2},{value:"Fields of Fields of Fields of Fields...",id:"fields-of-fields-of-fields-of-fields",level:2},{value:"Fanouts",id:"fanouts",level:2},{value:"Propagation across Arguments",id:"propagation-across-arguments",level:2}],u=(p="FbKnownFalseNegatives",function(e){return console.warn("Component "+p+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.mdx)("div",e)});var p;const m={toc:d};function h(e){let{components:n,...t}=e;return(0,r.mdx)("wrapper",(0,o.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,r.mdx)("p",null,"Like any static analysis tools, Mariana Trench has false negatives. This documents the more well-known places where taint is dropped. Note that this is not an exhaustive list. See ",(0,r.mdx)("a",{parentName:"p",href:"/docs/debugging-fp-fns"},"this wiki")," for instructions on how to debug them."),(0,r.mdx)("p",null,"Many of these options are ",(0,r.mdx)("em",{parentName:"p"},"configurable"),", not hard limits. There are analysis time, memory, and quality tradeoffs."),(0,r.mdx)("h2",{id:"trace-too-long"},"Trace too Long"),(0,r.mdx)("p",null,"Mariana Trench stops propagating taint beyond a certain depth. This depth is currently configured at 7. In code:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre"},"// This method has depth 1.\npublic int get_source_1() { return source(); }\n\n// This method has depth 2.\npublic int get_source_2() { return get_source_1(); }\n\n...\n\n// This method has depth 7.\npublic int get_source_7() { return get_source_6(); }\n\n// This method theoretically has depth 8, but MT drops the source here.\npublic int get_source_8() { return get_source_7(); }\n")),(0,r.mdx)("p",null,(0,r.mdx)("strong",{parentName:"p"},"Workaround:")," If the chain of wrappers obviously leads to a source or sink, instead of defining the source at ",(0,r.mdx)("inlineCode",{parentName:"p"},"source()"),", one could write an additional model marking ",(0,r.mdx)("inlineCode",{parentName:"p"},"get_source_7()")," as a source."),(0,r.mdx)("h2",{id:"fields-of-fields-of-fields-of-fields"},"Fields of Fields of Fields of Fields..."),(0,r.mdx)("p",null,"Taint of an object is dropped when it occurs too deep within the object. This depth is configured at 4. In code:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre"},"public void taintedThis() {\n  this.mField1 = source(); // This is OK\n  this.mField1.mField2.mField3.mField4.mField5 = source(); // This gets dropped\n}\n")),(0,r.mdx)("p",null,(0,r.mdx)("strong",{parentName:"p"},"Workaround:")," This isn\u2019t much of a workaround, but one can manually configure the source on \u201cthis.mField1.....mField4\u201d instead. This will be a form of over-abstraction and could lead to false positives."),(0,r.mdx)("h2",{id:"fanouts"},"Fanouts"),(0,r.mdx)("p",null,"If a virtual method has too many overrides, beyond a certain number (currently configured at 40), we stop considering all overrides and look only at the direct method being called. In code:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre"},"interface IFace {\n  public int possibleSource();\n}\n\nclass Class1 implements IFace {\n  public int possibleSource() { return 1; }\n}\n...\n\nclass Class41 implements IFace {\n  public int possibleSource() { return source(); }\n}\n\nint maybeIssue(IFace iface) {\n  // The source will get dropped here because there are too many overrides.\n  // MT will not report an issue.\n  sink(iface.possibleSource());\n}\n\n\n")),(0,r.mdx)("p",null,(0,r.mdx)("strong",{parentName:"p"},"Workaround:")," Unfortunately, there are no known workarounds."),(0,r.mdx)("h2",{id:"propagation-across-arguments"},"Propagation across Arguments"),(0,r.mdx)("p",null,"Mariana Trench computes propagations for each method (this may be known as \u201ctito\u201d (taint-in-taint-out) in other tools). Propagations tell the analysis that if an argument is tainted by a source, whether its return value, or the method\u2019s \u201cthis\u201d object become tainted by the argument. However, without explictly specifying ",(0,r.mdx)("inlineCode",{parentName:"p"},"--propagate-across-arguments"),", Mariana Trench does not propagate taint from one argument to another. In code:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre"},'void setIntentValue(Intent intent, Uri uri) {\n  // MT sees that intent.putExtra has a propagation from uri (Argument(2)) to\n  // intent (Argument(0) or this).\n  intent.putExtra("label", uri);\n\n  // However, when it finishes analyzing setIntentValue, it will not track the\n  // propagation from uri to intent.\n}\n\nvoid falseNegative() {\n  Uri uri = source();\n  Intent intent = new Intent();\n\n  // If this were the code, MT will detect a source->sink flow at launchActivitySink.\n  // intent.putExtra("label", uri);\n\n  // MT loses the flow from uri->intent at this point.\n  setIntentValue(intent, uri);\n\n  launchActivitySink(intent);\n}\n')),(0,r.mdx)("p",null,(0,r.mdx)("strong",{parentName:"p"},"Workaround 1:")," Write an explicit propagation model for the method. While Mariana Trench does not infer propagations across arguments, it does allow manual specification of such models."),(0,r.mdx)("p",null,(0,r.mdx)("strong",{parentName:"p"},"Workaround 2:")," Enable ",(0,r.mdx)("inlineCode",{parentName:"p"},"--propagate-across-arguments"),", which enables taint propagation across method invocations for object. Note that the behaviour is enabled globally, meaning that this may incur a significant runtime and memory overhead."),(0,r.mdx)(a.FbInternalOnly,{mdxType:"FbInternalOnly"}," ",(0,r.mdx)(u,{mdxType:"FbKnownFalseNegatives"})," "))}h.isMDXComponent=!0}}]);
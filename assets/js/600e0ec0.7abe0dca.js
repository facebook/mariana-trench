"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[811],{3905:(e,n,t)=>{t.r(n),t.d(n,{MDXContext:()=>c,MDXProvider:()=>h,mdx:()=>u,useMDXComponents:()=>m,withMDXComponents:()=>d});var i=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(){return r=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var i in t)Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i])}return e},r.apply(this,arguments)}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,i,a=function(e,n){if(null==e)return{};var t,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)t=r[i],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)t=r[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var c=i.createContext({}),d=function(e){return function(n){var t=m(n.components);return i.createElement(e,r({},n,{components:t}))}},m=function(e){var n=i.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},h=function(e){var n=m(e.components);return i.createElement(c.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},f=i.forwardRef((function(e,n){var t=e.components,a=e.mdxType,r=e.originalType,o=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=m(t),h=a,f=d["".concat(o,".").concat(h)]||d[h]||p[h]||r;return t?i.createElement(f,l(l({ref:n},c),{},{components:t})):i.createElement(f,l({ref:n},c))}));function u(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var r=t.length,o=new Array(r);o[0]=f;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var c=2;c<r;c++)o[c]=t[c];return i.createElement.apply(null,o)}return i.createElement.apply(null,t)}f.displayName="MDXCreateElement"},83703:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>f,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var i=t(87462),a=(t(67294),t(3905)),r=t(86341);const o={id:"android-lifecycles",title:"Android/API Lifecycles",sidebar_label:"Android/API Lifecycles"},l=void 0,s={unversionedId:"android-lifecycles",id:"android-lifecycles",title:"Android/API Lifecycles",description:"Background",source:"@site/documentation/android_lifecycles.md",sourceDirName:".",slug:"/android-lifecycles",permalink:"/docs/android-lifecycles",draft:!1,editUrl:"https://github.com/facebook/mariana-trench/tree/main/documentation/website/documentation/android_lifecycles.md",tags:[],version:"current",frontMatter:{id:"android-lifecycles",title:"Android/API Lifecycles",sidebar_label:"Android/API Lifecycles"},sidebar:"docs",previous:{title:"Shims",permalink:"/docs/shims"},next:{title:"Feature Glossary",permalink:"/docs/feature-descriptions"}},c={},d=[{value:"Background",id:"background",level:2},{value:"Lifecycle Configuration",id:"lifecycle-configuration",level:2},{value:"Lifecycle Definition",id:"lifecycle-definition",level:2},{value:"Linear Lifecycles",id:"linear-lifecycles",level:3},{value:"Lifecycle Graphs",id:"lifecycle-graphs",level:3},{value:"Method Generation for Lifecycle Graphs",id:"method-generation-for-lifecycle-graphs",level:4}],m=(h="FbAndroidLifecycles",function(e){return console.warn("Component "+h+" was not imported, exported, or provided by MDXProvider as global scope"),(0,a.mdx)("div",e)});var h;const p={toc:d};function f(e){let{components:n,...t}=e;return(0,a.mdx)("wrapper",(0,i.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,a.mdx)("h2",{id:"background"},"Background"),(0,a.mdx)("p",null,"Framework classes often provide overridable methods that subclasses can override. These methods are frequently executed in some sequence. The most direct example of this would be the ",(0,a.mdx)("a",{parentName:"p",href:"https://developer.android.com/guide/components/activities/activity-lifecycle"},"Activity lifecycle"),". Sub-classes implement methods like onCreate(), onStart(), onResume(), etc. which is internally chained up in the base class."),(0,a.mdx)("p",null,"The analysis may see this chain if the code for the base class is available. However, because the base class can be overridden by many different children, the analysis cannot easily differentiate between flows ",(0,a.mdx)("inlineCode",{parentName:"p"},"Child1.onCreate() -> Child1.onStart()")," and ",(0,a.mdx)("inlineCode",{parentName:"p"},"Child1.onCreate() -> Child2.onStart()"),". The latter could result in a false positives. There could also be too many children and which causes the analysis to drop taint and fail to find any flow."),(0,a.mdx)("p",null,"To get around this, we allow users to define lifecycles for these framework classes."),(0,a.mdx)("h2",{id:"lifecycle-configuration"},"Lifecycle Configuration"),(0,a.mdx)(r.FbInternalOnly,{mdxType:"FbInternalOnly"}," ",(0,a.mdx)(m,{mdxType:"FbAndroidLifecycles"})," "),(0,a.mdx)(r.OssOnly,{mdxType:"OssOnly"},(0,a.mdx)("p",null,"The default lifecycles are defined in ",(0,a.mdx)("a",{parentName:"p",href:"https://github.com/facebook/mariana-trench/blob/main/configuration/lifecycles.json"},"configuration/lifecycles.json"),".")),(0,a.mdx)("h2",{id:"lifecycle-definition"},"Lifecycle Definition"),(0,a.mdx)("p",null,"Lifecycles are defined in a JSON file and passed into the analysis via the ",(0,a.mdx)("inlineCode",{parentName:"p"},"--lifecycles-paths")," option. The definition contains three basic components, a ",(0,a.mdx)("inlineCode",{parentName:"p"},'"base_class_name"'),", a ",(0,a.mdx)("inlineCode",{parentName:"p"},'"method_name"'),", and set of overridable methods (callees) with their name and prototypes. Mariana Trench internally creates artificial methods with signature ",(0,a.mdx)("inlineCode",{parentName:"p"},"<child of base_class_name>.<method_name>(args for callees)")," that invokes the callees."),(0,a.mdx)("p",null,"A few notes on lifecycle definitions in general:"),(0,a.mdx)("ul",null,(0,a.mdx)("li",{parentName:"ul"},"The ",(0,a.mdx)("inlineCode",{parentName:"li"},'"method_name"')," must be unique across all lifecycles. Children could extend multiple base classes. If their respective lifecycle definitions share a ",(0,a.mdx)("inlineCode",{parentName:"li"},'"method_name"'),", there will be a conflict."),(0,a.mdx)("li",{parentName:"ul"},"Only children at the leaves of the class hierarchy will have the artificial method created, so taint flow will only be detected in these classes."),(0,a.mdx)("li",{parentName:"ul"},"All callee methods are expected to be defined in the base class and is validated to detect invalid configurations. However, if a method only exists in some derived classes down the class hierarchy, the callee should contain a ",(0,a.mdx)("inlineCode",{parentName:"li"},'"defined_in_derived_class"')," field. This field specifies the derived class where the method is defined, indicating Mariana Trench that the method does not exist in the base class, but in some classes extending it. This allows the method to be included in the generated lifecycle method.")),(0,a.mdx)("p",null,"The way the method is constructed (e.g., the order callees are invoked) depends on the kind of lifecycle definitions. Mariana Trench currently supports two kinds of lifecycle definitions: linear lifecycles and lifecycle graphs."),(0,a.mdx)("h3",{id:"linear-lifecycles"},"Linear Lifecycles"),(0,a.mdx)("p",null,"In linear lifecycle definitions, the callees are defined in the ",(0,a.mdx)("inlineCode",{parentName:"p"},'"callees"'),' array. The analysis generates the artificial method that invokes the callees in the order defined in the array (thus the name "linear"). Here is a sample definition:'),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-json"},'  {\n    "base_class_name": "Landroidx/fragment/app/FragmentActivity;",\n    "method_name": "activity_lifecycle_wrapper",\n    "callees": [\n      {\n        "method_name": "onCreate",\n        "return_type": "V",\n        "argument_types": [\n          "Landroid/os/Bundle;"\n        ]\n      },\n      {\n        "method_name": "onStart",\n        "return_type": "V",\n        "argument_types": []\n      },\n      {\n        "method_name": "onTest",\n        "return_type": "V",\n        "argument_types": [\n          "Ljava/lang/Object;"\n        ],\n        "defined_in_derived_class": "Lcom/facebook/marianatrench/integrationtests/FragmentOneActivity;"\n      }\n    ]\n  }\n')),(0,a.mdx)("h3",{id:"lifecycle-graphs"},"Lifecycle Graphs"),(0,a.mdx)("p",null,"One issue with the linear lifecycle definition is that it does not model more complex lifecycle transitions in real-world settings. For example, when the user navigates away from the activity, spends some time in other activity, and then navigates back, the ",(0,a.mdx)("inlineCode",{parentName:"p"},"onStart")," method would be called again. This state transition loop cannot be captured by linear lifecycle definitions."),(0,a.mdx)("p",null,"The lifecycle graph aims to solve this issue by allowing users to specify the transition relationships between the lifecycle states together with their corresponding methods as graphs. A sample lifecycle graph definition looks like this:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-json"},'  {\n    "base_class_name": "Landroid/app/Activity;",\n    "method_name": "activity_lifecycle_wrapper",\n    "control_flow_graph": {\n      "entry": {\n        "instructions": [\n          {\n            "method_name": "<init>",\n            "return_type": "V",\n            "argument_types": []\n          }\n        ],\n        "successors": [\n          "onCreate"\n        ]\n      },\n      "onCreate": {\n        "instructions": [\n          {\n            "method_name": "onCreate",\n            "return_type": "V",\n            "argument_types": [\n              "Landroid/os/Bundle;"\n            ]\n          }\n        ],\n        "successors": [\n          "exit"\n        ]\n      },\n      "exit": {\n        "instructions": [\n          {\n            "method_name": "onStart",\n            "return_type": "V",\n            "argument_types": []\n          }\n        ],\n        "successors": [\n          "onCreate"\n        ]\n      }\n    }\n  }\n')),(0,a.mdx)("p",null,"Several important points to note for the definition:"),(0,a.mdx)("ul",null,(0,a.mdx)("li",{parentName:"ul"},"By defining the ",(0,a.mdx)("inlineCode",{parentName:"li"},'"control_flow_graph"')," field instead of ",(0,a.mdx)("inlineCode",{parentName:"li"},'"callees"')," in linear lifecycles, Mariana Trench will automatically treat this definition as a lifecycle graph."),(0,a.mdx)("li",{parentName:"ul"},"Each object in the ",(0,a.mdx)("inlineCode",{parentName:"li"},'"control_flow_graph"')," is a graph node that represents the lifecycle state. For each node, the ",(0,a.mdx)("inlineCode",{parentName:"li"},'"instructions"')," array contains the callees that should be invoked in the current state. The ",(0,a.mdx)("inlineCode",{parentName:"li"},'"successors"')," array contains keys of the states that the current state could transit to (e.g. ",(0,a.mdx)("inlineCode",{parentName:"li"},'"onCreate"')," would transit to ",(0,a.mdx)("inlineCode",{parentName:"li"},'"onStart"'),")."),(0,a.mdx)("li",{parentName:"ul"},"There are two special node names, ",(0,a.mdx)("inlineCode",{parentName:"li"},'"entry"')," and ",(0,a.mdx)("inlineCode",{parentName:"li"},'"exit"'),", which corresponds to the entry and exit nodes of the graph. The entry node is required. The exit node is optional, but any node that is not the exit node must have at least one successor.")),(0,a.mdx)("h4",{id:"method-generation-for-lifecycle-graphs"},"Method Generation for Lifecycle Graphs"),(0,a.mdx)("p",null,"Internally, Mariana Trench will create one basic block for each graph node. The basic block will contain invocations to the methods associated with the node, and end with a ",(0,a.mdx)("inlineCode",{parentName:"p"},"switch")," that connects it to each of its successors. As an example, the above configuration may generate the following code for a class ",(0,a.mdx)("inlineCode",{parentName:"p"},"MainActivity")," that extends ",(0,a.mdx)("inlineCode",{parentName:"p"},"android.app.Activity"),":"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre"},"Block 0 (entry):\n  IOPCODE_LOAD_PARAM_OBJECT v0\n  IOPCODE_LOAD_PARAM_OBJECT v1\n  Successors: {3}\nBlock 1:\n  INVOKE_VIRTUAL v0, v1, Lcom/facebook/marianatrench/integrationtests/MainActivity;.onCreate:(Landroid/os/Bundle;)V\n  SWITCH v2\n  Successors: {2}\nBlock 2:\n  INVOKE_VIRTUAL v0, Lcom/facebook/marianatrench/integrationtests/MainActivity;.onStart:()V\n  SWITCH v3\n  Successors: {4, 1}\nBlock 3:\n  INVOKE_VIRTUAL v0, Lcom/facebook/marianatrench/integrationtests/MainActivity;.<init>:()V\n  SWITCH v4\n  Successors: {1}\nBlock 4:\n  RETURN_VOID\n")),(0,a.mdx)("p",null,"Here, the block 1, 2, and 3 maps to the ",(0,a.mdx)("inlineCode",{parentName:"p"},'"onCreate"'),", ",(0,a.mdx)("inlineCode",{parentName:"p"},'"exit"'),", and ",(0,a.mdx)("inlineCode",{parentName:"p"},'"entry"')," nodes, respectively. Block 0 is the real entry block of the method, which loads all parameters and jumps into the block associated with the ",(0,a.mdx)("inlineCode",{parentName:"p"},'"entry"')," node (i.e., block 3). Block 4 is the real exit node of the method, which contains the return instruction. The block associated with the ",(0,a.mdx)("inlineCode",{parentName:"p"},'"exit"')," node (i.e., block 2) will have a branch to this real exit block."))}f.isMDXComponent=!0}}]);
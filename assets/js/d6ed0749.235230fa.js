"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[133],{3905:(e,n,a)=>{a.r(n),a.d(n,{MDXContext:()=>d,MDXProvider:()=>u,mdx:()=>x,useMDXComponents:()=>p,withMDXComponents:()=>m});var t=a(67294);function i(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function r(){return r=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var a=arguments[n];for(var t in a)Object.prototype.hasOwnProperty.call(a,t)&&(e[t]=a[t])}return e},r.apply(this,arguments)}function o(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,t)}return a}function l(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?o(Object(a),!0).forEach((function(n){i(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function s(e,n){if(null==e)return{};var a,t,i=function(e,n){if(null==e)return{};var a,t,i={},r=Object.keys(e);for(t=0;t<r.length;t++)a=r[t],n.indexOf(a)>=0||(i[a]=e[a]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(t=0;t<r.length;t++)a=r[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var d=t.createContext({}),m=function(e){return function(n){var a=p(n.components);return t.createElement(e,r({},n,{components:a}))}},p=function(e){var n=t.useContext(d),a=n;return e&&(a="function"==typeof e?e(n):l(l({},n),e)),a},u=function(e){var n=p(e.components);return t.createElement(d.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},h=t.forwardRef((function(e,n){var a=e.components,i=e.mdxType,r=e.originalType,o=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),m=p(a),u=i,h=m["".concat(o,".").concat(u)]||m[u]||c[u]||r;return a?t.createElement(h,l(l({ref:n},d),{},{components:a})):t.createElement(h,l({ref:n},d))}));function x(e,n){var a=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=a.length,o=new Array(r);o[0]=h;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,o[1]=l;for(var d=2;d<r;d++)o[d]=a[d];return t.createElement.apply(null,o)}return t.createElement.apply(null,a)}h.displayName="MDXCreateElement"},31797:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>c,frontMatter:()=>r,metadata:()=>l,toc:()=>d});var t=a(87462),i=(a(67294),a(3905));const r={id:"models",title:"Models & Model Generators",sidebar_label:"Models & Model Generators"},o=void 0,l={unversionedId:"models",id:"models",title:"Models & Model Generators",description:"The main way to configure the analysis is through defining model generators. Each model generator defines (1) a filter, made up of constraints to specify the methods (or fields) for which a model should be generated, and (2) a model, an abstract representation of how data flows through a method.",source:"@site/documentation/models.md",sourceDirName:".",slug:"/models",permalink:"/docs/models",draft:!1,editUrl:"https://github.com/facebook/mariana-trench/tree/main/documentation/website/documentation/models.md",tags:[],version:"current",frontMatter:{id:"models",title:"Models & Model Generators",sidebar_label:"Models & Model Generators"},sidebar:"docs",previous:{title:"Rules",permalink:"/docs/rules"},next:{title:"Shims",permalink:"/docs/shims"}},s={},d=[{value:"Models",id:"models",level:2},{value:"Method name format",id:"method-name-format",level:3},{value:"Access path format",id:"access-path-format",level:3},{value:"Kinds",id:"kinds",level:3},{value:"Sources",id:"sources",level:3},{value:"Sinks",id:"sinks",level:3},{value:"Return Sinks",id:"return-sinks",level:3},{value:"Propagation",id:"propagation",level:3},{value:"Features",id:"features",level:3},{value:"Attach to Sources",id:"attach-to-sources",level:4},{value:"Attach to Sinks",id:"attach-to-sinks",level:4},{value:"Attach to Propagations",id:"attach-to-propagations",level:4},{value:"Add Features to Arguments",id:"add-features-to-arguments",level:4},{value:"Via-type Features",id:"via-type-features",level:4},{value:"Via-value Features",id:"via-value-features",level:4},{value:"Annotation Features",id:"annotation-features",level:4},{value:"Taint Broadening",id:"taint-broadening",level:3},{value:"Propagation Broadening",id:"propagation-broadening",level:4},{value:"Issue Broadening Feature",id:"issue-broadening-feature",level:5},{value:"Widen Broadening Feature",id:"widen-broadening-feature",level:5},{value:"Sanitizers",id:"sanitizers",level:3},{value:"Kind-specific Sanitizers",id:"kind-specific-sanitizers",level:4},{value:"Port-specific Sanitizers",id:"port-specific-sanitizers",level:4},{value:"Modes",id:"modes",level:3},{value:"Default model",id:"default-model",level:3},{value:"Field Models",id:"field-models",level:3},{value:"Literal Models",id:"literal-models",level:3},{value:"Model Generators",id:"model-generators",level:2},{value:"Example",id:"example",level:3},{value:"Specification",id:"specification",level:3},{value:"Development",id:"development",level:3},{value:"When Sources or Sinks don&#39;t appear in Results",id:"when-sources-or-sinks-dont-appear-in-results",level:4}],m=(p="FbModels",function(e){return console.warn("Component "+p+" was not imported, exported, or provided by MDXProvider as global scope"),(0,i.mdx)("div",e)});var p;const u={toc:d};function c(e){let{components:n,...a}=e;return(0,i.mdx)("wrapper",(0,t.Z)({},u,a,{components:n,mdxType:"MDXLayout"}),(0,i.mdx)("p",null,"The main way to configure the analysis is through defining model generators. Each model generator defines (1) a ",(0,i.mdx)("strong",{parentName:"p"},"filter"),", made up of constraints to specify the methods (or fields) for which a model should be generated, and (2) a ",(0,i.mdx)("strong",{parentName:"p"},"model"),", an abstract representation of how data flows through a method."),(0,i.mdx)("p",null,"Model generators are what define Sink and Source kinds which are the key component of ",(0,i.mdx)("a",{parentName:"p",href:"/docs/rules"},"Rules"),". Model generators can do other things too, like attach ",(0,i.mdx)("strong",{parentName:"p"},"features")," (a.k.a. breadcrumbs) to flows and ",(0,i.mdx)("strong",{parentName:"p"},"sanitize"),' (redact) flows which go through certain "data-safe" methods (e.g. a method which hashes a user\'s password).'),(0,i.mdx)("p",null,"Filters are conceptually straightforward. Thus, this page focuses heavily on conceptualizing and providing examples for the various types of models. See the ",(0,i.mdx)("a",{parentName:"p",href:"#model-generators"},"Model Generators")," section for full implementation documentation for both filters and models."),(0,i.mdx)("h2",{id:"models"},"Models"),(0,i.mdx)("p",null,"A model is an abstract representation of how data flows through a method."),(0,i.mdx)("p",null,"A model essentialy consists of:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("a",{parentName:"li",href:"#sources"},"Sources"),": a set of sources that the method produces or receives on parameters;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("a",{parentName:"li",href:"#sinks"},"Sinks"),": a set of sinks on the method;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("a",{parentName:"li",href:"#propagation"},"Propagation"),": a description of how the method propagates taint coming into it (e.g, the first parameter updates the second, the second parameter updates the return value, etc.);"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("a",{parentName:"li",href:"#attach-to-sources"},"Attach to Sources"),": a set of features/breadcrumbs to add on an any sources flowing out of the method;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("a",{parentName:"li",href:"#attach-to-sinks"},"Attach to Sinks"),": a set of features/breadcrumbs to add on sinks of a given parameter;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("a",{parentName:"li",href:"#attach-to-propagations"},"Attach to Propagations"),": a set of features/breadcrumbs to add on propagations for a given parameter or return value;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("a",{parentName:"li",href:"#add-features-to-arguments"},"Add Features to Arguments"),": a set of features/breadcrumbs to add on any taint that might flow in a given parameter;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("a",{parentName:"li",href:"#sanitizers"},"Sanitizers"),": specifications of taint flows to stop;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("a",{parentName:"li",href:"#modes"},"Modes"),": a set of flags describing specific behaviors (see below).")),(0,i.mdx)("p",null,"Models can be specified in JSON. For example to mark the string parameter to our ",(0,i.mdx)("inlineCode",{parentName:"p"},"Logger.log")," function as a sink we can specify it as"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "find": "methods",\n  "where": [\n    {\n      "constraint": "signature_match",\n      "parent": "Lcom/example/Logger;",\n      "name": "log"\n    }\n  ],\n  "model": {\n    "sinks": [\n      {\n        "kind": "Logging",\n        "port": "Argument(1)"\n      }\n    ]\n  }\n}\n')),(0,i.mdx)("p",null,"Note that the naming of methods follow the ",(0,i.mdx)("a",{parentName:"p",href:"#method-name-format"},"Dalvik's bytecode format"),"."),(0,i.mdx)("h3",{id:"method-name-format"},"Method name format"),(0,i.mdx)("p",null,"The format used for method names is:"),(0,i.mdx)("p",null,(0,i.mdx)("inlineCode",{parentName:"p"},"<className>.<methodName>:(<parameterType1><parameterType2>)<returnType>")),(0,i.mdx)("p",null,"Example: ",(0,i.mdx)("inlineCode",{parentName:"p"},"Landroidx/fragment/app/Fragment;.startActivity:(Landroid/content/Intent;)V")),(0,i.mdx)("p",null,"For the parameters and return types use the following table to pick the correct one (please refer to ",(0,i.mdx)("a",{parentName:"p",href:"https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.3.2-200"},"JVM doc")," for more details)"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"V - void"),(0,i.mdx)("li",{parentName:"ul"},"Z - boolean"),(0,i.mdx)("li",{parentName:"ul"},"B - byte"),(0,i.mdx)("li",{parentName:"ul"},"S - short"),(0,i.mdx)("li",{parentName:"ul"},"C - char"),(0,i.mdx)("li",{parentName:"ul"},"I - int"),(0,i.mdx)("li",{parentName:"ul"},"J - long (64 bits)"),(0,i.mdx)("li",{parentName:"ul"},"F - float"),(0,i.mdx)("li",{parentName:"ul"},"D - double (64 bits)")),(0,i.mdx)("p",null,"Classes take the form ",(0,i.mdx)("inlineCode",{parentName:"p"},"Lpackage/name/ClassName;")," - where the leading ",(0,i.mdx)("inlineCode",{parentName:"p"},"L")," indicates that it is a class type, ",(0,i.mdx)("inlineCode",{parentName:"p"},"package/name/")," is the package that the class is in. A nested class will take the form ",(0,i.mdx)("inlineCode",{parentName:"p"},"Lpackage/name/ClassName$NestedClassName")," (the ",(0,i.mdx)("inlineCode",{parentName:"p"},"$")," will need to be double escaped ",(0,i.mdx)("inlineCode",{parentName:"p"},"\\\\$")," in json regex)."),(0,i.mdx)("blockquote",null,(0,i.mdx)("p",{parentName:"blockquote"},(0,i.mdx)("strong",{parentName:"p"},"NOTE 1:")," Instance (i.e, non-static) method parameters are indexed starting from 1! The 0th parameter is the ",(0,i.mdx)("inlineCode",{parentName:"p"},"this")," parameter in dalvik byte-code. For static method parameter, indices start from 0.")),(0,i.mdx)("blockquote",null,(0,i.mdx)("p",{parentName:"blockquote"},(0,i.mdx)("strong",{parentName:"p"},"NOTE 2:")," In a constructor (\\<init",">"," method), parameters are also indexed starting from 1. The 0th parameter refers to the instance being constructed, similar to the ",(0,i.mdx)("inlineCode",{parentName:"p"},"this")," reference.")),(0,i.mdx)("h3",{id:"access-path-format"},"Access path format"),(0,i.mdx)("p",null,'An access path describes the symbolic location of a taint. This is commonly used to indicate where a source or a sink originates from. The "port" field of any model is represented by an access path.'),(0,i.mdx)("p",null,"An access path is composed of a root and a path."),(0,i.mdx)("p",null,"The root is either:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"Return"),", representing the returned value;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"Argument(x)")," (where ",(0,i.mdx)("inlineCode",{parentName:"li"},"x")," is an integer), representing the parameter number ",(0,i.mdx)("inlineCode",{parentName:"li"},"x"),";")),(0,i.mdx)("p",null,"The path is a (possibly empty) list of path elements. A path element can be any of the following kinds:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"field"),": represents a field name. String encoding is a dot followed by the field name: ",(0,i.mdx)("inlineCode",{parentName:"li"},".field_name"),";"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"index"),": represents a user defined index for dictionary like objects. String encoding uses square braces to enclose any user defined index: ",(0,i.mdx)("inlineCode",{parentName:"li"},"[index_name]"),";"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"any index"),": represents any or unresolved indices in dictionary like objects. String encoding is an asterisk enclosed in square braces: ",(0,i.mdx)("inlineCode",{parentName:"li"},"[*]"),";"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"index from value of"),": captures the value of the specified callable's port seen at its callsites during taint flow analysis as an ",(0,i.mdx)("inlineCode",{parentName:"li"},"index")," or ",(0,i.mdx)("inlineCode",{parentName:"li"},"any index")," (if the value cannot be resolved). String encoding uses ",(0,i.mdx)("em",{parentName:"li"},"argument root")," to specify the callable's port and encloses it in ",(0,i.mdx)("inlineCode",{parentName:"li"},"[<"),"...",(0,i.mdx)("inlineCode",{parentName:"li"},">]")," to represent that its value is resolved at the callsite to create an index: ",(0,i.mdx)("inlineCode",{parentName:"li"},"[<Argument(x)>]"),";")),(0,i.mdx)("p",null,"Examples:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"Argument(1).name")," corresponds to the ",(0,i.mdx)("em",{parentName:"li"},"field")," ",(0,i.mdx)("inlineCode",{parentName:"li"},"name")," of the second parameter;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"Argument(1)[name]")," corresponds to the ",(0,i.mdx)("em",{parentName:"li"},"index")," ",(0,i.mdx)("inlineCode",{parentName:"li"},"name")," of the dictionary like second parameter;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"Argument(1)[*]")," corresponds to ",(0,i.mdx)("em",{parentName:"li"},"any index")," of the dictionary like second parameter;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"Argument(1)[<Argument(2)>]")," corresponds to an ",(0,i.mdx)("em",{parentName:"li"},"index")," of the dictionary like second parameter whose value is resolved from the third parameter;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"Return")," corresponds to the returned value;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"Return.x")," corresponds to the field ",(0,i.mdx)("inlineCode",{parentName:"li"},"x")," of the returned value;")),(0,i.mdx)("h3",{id:"kinds"},"Kinds"),(0,i.mdx)("p",null,"A source has a ",(0,i.mdx)("strong",{parentName:"p"},"kind")," that describes its content (e.g, user input, file system, etc). A sink also has a ",(0,i.mdx)("strong",{parentName:"p"},"kind")," that describes the operation the method performs (e.g, execute a command, read a file, etc.). Kinds can be arbitrary strings (e.g, ",(0,i.mdx)("inlineCode",{parentName:"p"},"UserInput"),"). We usually avoid whitespaces."),(0,i.mdx)("h3",{id:"sources"},"Sources"),(0,i.mdx)("p",null,"Sources describe taint ",(0,i.mdx)("em",{parentName:"p"},"produced")," or ",(0,i.mdx)("em",{parentName:"p"},"received")," by a given method. A source has a ",(0,i.mdx)("strong",{parentName:"p"},"kind")," that describes its content (e.g, user input, file system, etc)."),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"A method ",(0,i.mdx)("em",{parentName:"li"},"produces")," a source kind if invoking the method implies the source kind ",(0,i.mdx)("em",{parentName:"li"},"flows out")," from it. The source kind can flow out via the return value or through a parameter (pass by reference semantics)."),(0,i.mdx)("li",{parentName:"ul"},"A method ",(0,i.mdx)("em",{parentName:"li"},"receives")," a source kind if a source kind is always assumed to ",(0,i.mdx)("em",{parentName:"li"},"flow in")," via an argument regardless of the method's callsite.")),(0,i.mdx)("p",null,"Here is an example where the source ",(0,i.mdx)("em",{parentName:"p"},"flows out")," through the return value:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},'public static String getPath() {\n    return System.getenv().get("PATH");\n}\n')),(0,i.mdx)("p",null,"The JSON model generator for this method could be:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "find": "methods",\n  "where": [\n    {\n      "constraint": "signature_match",\n      "parent": "Lcom/example/Class;",\n      "name": "getPath"\n    }\n  ],\n  "model": {\n    "sources": [\n      {\n        "kind": "UserControlled",\n        "port": "Return"\n      }\n    ]\n  }\n}\n')),(0,i.mdx)("p",null,"Here is an example where the source ",(0,i.mdx)("em",{parentName:"p"},"flows in")," via an argument:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},"class MyActivity extends Activity {\n  public void onNewIntent(Intent intent) {\n    // intent should be considered a source here.\n  }\n}\n")),(0,i.mdx)("p",null,"The JSON model generator for this method could be:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "find": "methods",\n  "where": [\n    {\n      "constraint": "signature_match",\n      "extends": "Landroid/app/Activity",\n      "name": "onNewIntent"\n    }\n  ],\n  "model": {\n    "sources": [\n      {\n        "kind": "UserControlled",\n        "port": "Argument(1)"\n      }\n    ]\n  }\n}\n')),(0,i.mdx)("p",null,"Here is an example where source ",(0,i.mdx)("em",{parentName:"p"},"flows out")," via an argument:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},"public static void updateIntent(Intent intent) {}\n\nvoid createAndUseIntent() {\n  MyIntent myIntent = new MyIntent();\n  // myIntent is not a source. This is safe.\n  sink(myIntent);\n\n  updateIntent(myIntent);\n  // myIntent is now a source. This is now a flow.\n  sink(myIntent);\n}\n")),(0,i.mdx)("p",null,"The JSON model generator for this method could be:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "find": "methods",\n  "where": [\n    {\n     "constraint": "signature_match",\n      "parent": "Lcom/example/Class;",\n      "name": "updateIntent"\n    }\n  ],\n  "model": {\n    "generations": [\n      {\n        "kind": "UserControlled",\n        "port": "Argument(0)"\n      }\n    ]\n  }\n}\n')),(0,i.mdx)("p",null,'Note on the use of "generations" vs "sources": "generations" indicates that the source kind is ',(0,i.mdx)("em",{parentName:"p"},"produced")," and ",(0,i.mdx)("em",{parentName:"p"},"flows out"),' via the specified port. When the port is "Return", "generations" and "sources" are equivalent.'),(0,i.mdx)("p",null,'"generations" are also useful to mark the ',(0,i.mdx)("inlineCode",{parentName:"p"},"this")," reference of an instance as sources. Instances are created using constructors, which are special ",(0,i.mdx)("inlineCode",{parentName:"p"},"<init>")," methods with return type void. But, as mentioned in Note 2 above, constructors create a special 0th parameter to refer to the instance being constructed (i.e. ",(0,i.mdx)("inlineCode",{parentName:"p"},"this"),"). Here is an example where a constructor marks the instance as a source:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},"class SourceIntent extends Intent {\n  SourceIntent() {}\n}\n\nvoid createAndUseIntent() {\n  SourceIntent sourceIntent = new SourceIntent();\n  // sourceIntent is a source.\n  sink(myIntent);\n}\n")),(0,i.mdx)("p",null,"The JSON model generator for the constructor method could be:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "find": "methods",\n  "where": [\n    {\n     "constraint": "signature_match",\n      "parent": "Lcom/example/SourceIntent;",\n      "name": "<init>"\n    }\n  ],\n  "model": {\n    "generations": [\n      {\n        "kind": "UserControlled",\n        "port": "Argument(0)"\n      }\n    ]\n  }\n}\n')),(0,i.mdx)("h3",{id:"sinks"},"Sinks"),(0,i.mdx)("p",null,"Sinks describe dangerous or sensitive methods in the code. A sink has a ",(0,i.mdx)("strong",{parentName:"p"},"kind")," that represents the type of operation the method does (e.g, command execution, file system operation, etc). A sink must be attached to a given parameter of the method. A method can have multiple sinks."),(0,i.mdx)("p",null,"Here is an example of a sink:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},"public static String readFile(String path, String extension, int mode) {\n    // Return the content of the file path.extension\n}\n")),(0,i.mdx)("p",null,"Since ",(0,i.mdx)("inlineCode",{parentName:"p"},"path")," and ",(0,i.mdx)("inlineCode",{parentName:"p"},"extension")," can be used to read arbitrary files, we consider them sinks. We do not consider ",(0,i.mdx)("inlineCode",{parentName:"p"},"mode")," as a sink since we do not care whether the user can control it. The JSON model generator for this method could be:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "find": "methods",\n  "where": [\n    {\n      "constraint": "signature_match",\n      "parent": "Lcom/example/Class",\n      "name": "readFile"\n    }\n  ],\n  "model": {\n    "sinks": [\n      {\n        "kind": "FileRead",\n        "port": "Argument(0)"\n      },\n      {\n        "kind": "FileRead",\n        "port": "Argument(1)"\n      }\n    ]\n  }\n}\n')),(0,i.mdx)("h3",{id:"return-sinks"},"Return Sinks"),(0,i.mdx)("p",null,"Return sinks can be used to describe that a method should not return tainted information. A return sink is just a normal sink with a ",(0,i.mdx)("inlineCode",{parentName:"p"},"Return")," port."),(0,i.mdx)("h3",{id:"propagation"},"Propagation"),(0,i.mdx)("p",null,"Propagations \u2212 also called ",(0,i.mdx)("strong",{parentName:"p"},"tito")," (Taint In Taint Out) or ",(0,i.mdx)("strong",{parentName:"p"},"passthrough")," in other tools \u2212 describe how the method propagates taint. A propagation as an ",(0,i.mdx)("strong",{parentName:"p"},"input")," (where the taint comes from) and an ",(0,i.mdx)("strong",{parentName:"p"},"output")," (where the taint is moved to)."),(0,i.mdx)("p",null,"Here is an example of a propagation:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},"public static String concat(String x, String y) {\n  return x + y;\n}\n")),(0,i.mdx)("p",null,"The return value of the method can be controlled by both parameters, hence it has the propagations ",(0,i.mdx)("inlineCode",{parentName:"p"},"Argument(0) -> Return")," and ",(0,i.mdx)("inlineCode",{parentName:"p"},"Argument(1) -> Return"),". The JSON model generator for this method could be:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "find": "methods",\n  "where": [\n    {\n      "constraint": "signature_match",\n      "parent": "Lcom/example/Class",\n      "name": "concat"\n    }\n  ],\n  "model": {\n    "propagation": [\n      {\n        "input": "Argument(0)",\n        "output": "Return"\n      },\n      {\n        "input": "Argument(1)",\n        "output": "Return"\n      }\n    ]\n  }\n}\n')),(0,i.mdx)("h3",{id:"features"},"Features"),(0,i.mdx)("p",null,"Features (also called ",(0,i.mdx)("strong",{parentName:"p"},"breadcrumbs"),") can be used to tag a flow and help filtering issues. A feature describes a property of a flow. A feature can be any arbitrary string."),(0,i.mdx)("p",null,"For instance, the feature ",(0,i.mdx)("inlineCode",{parentName:"p"},"via-numerical-operator")," is used to describe that the data flows through a numerical operator such as an addition."),(0,i.mdx)("p",null,"Features are very useful to filter flows in the SAPP UI. E.g. flows with a cast from string to integer are can sometimes be less important during triaging since controlling an integer is more difficult to exploit than controlling a full string."),(0,i.mdx)("p",null,"Note that features ",(0,i.mdx)("strong",{parentName:"p"},"do not stop")," the flow, they just help triaging."),(0,i.mdx)("h4",{id:"attach-to-sources"},"Attach to Sources"),(0,i.mdx)("p",null,(0,i.mdx)("em",{parentName:"p"},"Attach to sources")," is used to add a set of ",(0,i.mdx)("a",{parentName:"p",href:"#features"},"features")," on any sources flowing out of a method through a given parameter or return value."),(0,i.mdx)("p",null,"For instance, if we want to add the feature ",(0,i.mdx)("inlineCode",{parentName:"p"},"via-signed")," to all sources flowing out of the given method:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},"public String getSignedCookie();\n")),(0,i.mdx)("p",null,"We could use the following JSON model generator:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "find": "methods",\n  "where": [\n    {\n      "constraint": "signature_match",\n      "parent": "Lcom/example/Class",\n      "name": "getSignedCookie"\n    }\n  ],\n  "model": {\n    "attach_to_sources": [\n      {\n        "features": [\n          "via-signed"\n        ],\n        "port": "Return"\n      }\n    ]\n  }\n}\n')),(0,i.mdx)("p",null,"Note that this is only useful for sources inferred by the analysis. If you know that ",(0,i.mdx)("inlineCode",{parentName:"p"},"getSignedCookie")," returns a source of a given kind, you should use a source instead."),(0,i.mdx)("h4",{id:"attach-to-sinks"},"Attach to Sinks"),(0,i.mdx)("p",null,(0,i.mdx)("em",{parentName:"p"},"Attach to sinks")," is used to add a set of ",(0,i.mdx)("a",{parentName:"p",href:"#features"},"features")," on all sinks on the given parameter of a method."),(0,i.mdx)("p",null,"For instance, if we want to add the feature ",(0,i.mdx)("inlineCode",{parentName:"p"},"via-user")," on all sinks of the given method:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},"class User {\n  public static User findUser(String username) {\n    // The code here might use SQL, Thrift, or anything. We don't need to know.\n  }\n}\n")),(0,i.mdx)("p",null,"We could use the following JSON model generator:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "find": "methods",\n  "where": [\n    {\n      "constraint": "signature_match",\n      "parent": "Lcom/example/User",\n      "name": "findUser"\n    }\n  ],\n  "model": {\n    "attach_to_sinks": [\n      {\n        "features": [\n          "via-user"\n        ],\n        "port": "Argument(0)"\n      }\n    ]\n  }\n}\n')),(0,i.mdx)("p",null,"Note that this is only useful for sinks inferred by the analysis. If you know that ",(0,i.mdx)("inlineCode",{parentName:"p"},"findUser")," is a sink of a given kind, you should use a sink instead."),(0,i.mdx)("h4",{id:"attach-to-propagations"},"Attach to Propagations"),(0,i.mdx)("p",null,(0,i.mdx)("em",{parentName:"p"},"Attach to propagations")," is used to add a set of ",(0,i.mdx)("a",{parentName:"p",href:"#features"},"features")," on all propagations from or to a given parameter or return value of a method."),(0,i.mdx)("p",null,"For instance, if we want to add the feature ",(0,i.mdx)("inlineCode",{parentName:"p"},"via-concat")," to the propagations of the given method:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},"public static String concat(String x, String y);\n")),(0,i.mdx)("p",null,"We could use the following JSON model generator:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "find": "methods",\n  "where": [\n    {\n      "constraint": "signature_match",\n      "parent": "Lcom/example/Class",\n      "name": "concat"\n    }\n  ],\n  "model": {\n    "attach_to_propagations": [\n      {\n        "features": [\n          "via-concat"\n        ],\n        "port": "Return" // We could also use Argument(0) and Argument(1)\n      }\n    ]\n  }\n}\n')),(0,i.mdx)("p",null,"Note that this is only useful for propagations inferred by the analysis. If you know that ",(0,i.mdx)("inlineCode",{parentName:"p"},"concat")," has a propagation, you should model it as a propagation directly."),(0,i.mdx)("h4",{id:"add-features-to-arguments"},"Add Features to Arguments"),(0,i.mdx)("p",null,(0,i.mdx)("em",{parentName:"p"},"Add features to arguments")," is used to add a set of ",(0,i.mdx)("a",{parentName:"p",href:"#features"},"features")," on all sources that ",(0,i.mdx)("strong",{parentName:"p"},"might")," flow on a given parameter of a method."),(0,i.mdx)("p",null,(0,i.mdx)("em",{parentName:"p"},"Add features to arguments")," implies ",(0,i.mdx)("em",{parentName:"p"},"Attach to sources"),", ",(0,i.mdx)("em",{parentName:"p"},"Attach to sinks")," and ",(0,i.mdx)("em",{parentName:"p"},"Attach to propagations"),", but it also accounts for possible side effects at call sites."),(0,i.mdx)("p",null,"For instance:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},'public static void log(String message) {\n  System.out.println(message);\n}\npublic void buyView() {\n  String username = getParameter("username");\n  String product = getParameter("product");\n  log(username);\n  buy(username, product);\n}\n')),(0,i.mdx)("p",null,"Technically, the ",(0,i.mdx)("inlineCode",{parentName:"p"},"log")," method doesn't have any source, sink or propagation. We can use ",(0,i.mdx)("em",{parentName:"p"},"add features to arguments")," to add a feature ",(0,i.mdx)("inlineCode",{parentName:"p"},"was-logged")," on the flow from ",(0,i.mdx)("inlineCode",{parentName:"p"},'getParameter("username")')," to ",(0,i.mdx)("inlineCode",{parentName:"p"},"buy(username, product)"),". We could use the following JSON model generator for the ",(0,i.mdx)("inlineCode",{parentName:"p"},"log")," method:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "find": "methods",\n  "where": [\n    {\n      "constraint": "signature_match",\n      "parent": "Lcom/example/Class",\n      "name": "log"\n    }\n  ],\n  "model": {\n    "add_features_to_arguments": [\n      {\n        "features": [\n          "was-logged"\n        ],\n        "port": "Argument(0)"\n      }\n    ]\n  }\n}\n')),(0,i.mdx)("h4",{id:"via-type-features"},"Via-type Features"),(0,i.mdx)("p",null,(0,i.mdx)("em",{parentName:"p"},"Via-type")," features are used to keep track of the type of a callable\u2019s port seen at its callsites during taint flow analysis. They are specified in model generators within the \u201csources\u201d or \u201csinks\u201d field of a model with the \u201cvia_type_of\u201d field. It is mapped to a nonempty list of ports of the method for which we want to create via-type features."),(0,i.mdx)("p",null,"For example, if we were interested in the specific Activity subclasses with which the method below was called:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},"\npublic void startActivityForResult(Intent intent, int requestCode);\n\n// At some callsite:\nActivitySubclass activitySubclassInstance;\nactivitySubclassInstance.startActivityForResult(intent, requestCode);\n\n")),(0,i.mdx)("p",null,"we could use the following JSON to specify a via-type feature that would materialize as ",(0,i.mdx)("inlineCode",{parentName:"p"},"via-type:ActivitySubclass"),":"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "find": "methods",\n  "where": [\n    {\n      "constraint": "signature_match",\n      "extends": "Landroid/app/Activity",\n      "name": "startActivityForResult"\n    }\n  ],\n  "model": {\n    "sinks": [\n      {\n        "port": "Argument(1)",\n        "kind": "SinkKind",\n        "via_type_of": [\n          "Argument(0)"\n        ]\n      }\n    ]\n  }\n}\n')),(0,i.mdx)("h4",{id:"via-value-features"},"Via-value Features"),(0,i.mdx)("p",null,(0,i.mdx)("em",{parentName:"p"},"Via-value")," feature captures the value of the specified callable's port seen at its callsites during taint flow analysis. They are specified similar to ",(0,i.mdx)("inlineCode",{parentName:"p"},"Via-type"),' features -- in model generators within the "sources", "sinks"  or "add_features_to_arguments" field of a model with the "via_value_of" field. It is mapped to a nonempty list of ports of the method for which we want to create via-value features.'),(0,i.mdx)("p",null,"For example, if we were interested in the specific ",(0,i.mdx)("inlineCode",{parentName:"p"},"mode")," with which the method below was called:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},'public void log(String mode, String message);\n\nclass Constants {\n  public static final String MODE = "M1";\n}\n\n// At some callsite:\nlog(Constants.MODE, "error message");\n\n')),(0,i.mdx)("p",null,"we could use the following JSON to specify a via-value feature that would materialize as ",(0,i.mdx)("inlineCode",{parentName:"p"},"via-value:M1"),":"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "find": "methods",\n  "where": [\n    {\n      "constraint": "signature_match",\n      "parent": "Lcom/example/Class",\n      "name": "log"\n    }\n  ],\n  "model": {\n    "sinks": [\n      {\n        "port": "Argument(1)",\n        "kind": "SinkKind",\n        "via_value_of": [\n          "Argument(0)"\n        ]\n      }\n    ]\n  }\n}\n')),(0,i.mdx)("p",null,"Note that this only works for numeric and string literals. In cases where the argument is not a constant, the feature will appear as ",(0,i.mdx)("inlineCode",{parentName:"p"},"via-value:unknown"),"."),(0,i.mdx)("p",null,"Note: ",(0,i.mdx)("inlineCode",{parentName:"p"},"via_type_of")," and ",(0,i.mdx)("inlineCode",{parentName:"p"},"via_value_of")," allow specifying a tag, which will be provided in the instantiated breadcrumb. For instance ",(0,i.mdx)("inlineCode",{parentName:"p"},"via-foo-value:bar"),', for a tag "foo". This can be used to differentiate from other via-value or via-type breadcrumbs.'),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'"via_type_of": [\n  {\n    "port": "Argument(1)",\n    "tag": "differentiator"\n  }\n]\n')),(0,i.mdx)("p",null,"This would create the feature ",(0,i.mdx)("inlineCode",{parentName:"p"},"via-differentiator-type:Lcom/example/Class"),"."),(0,i.mdx)("p",null,"For backward compatibility, we allow these to be mixed with normal ports in a list"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'"via_value_of": [\n  "Argument(0)",\n  {\n    "port": "Argument(1)",\n    "tag": "error-mode"\n  },\n  "Argument(2)"\n]\n')),(0,i.mdx)("h4",{id:"annotation-features"},"Annotation Features"),(0,i.mdx)("p",null,"In model generators we can also use annotation features, which translate to regular user features based on annotation parameter values. This feature is also compatible with ",(0,i.mdx)("inlineCode",{parentName:"p"},"for_all_parameters"),"."),(0,i.mdx)("p",null,"Config example:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "model_generators": [\n    {\n      "find": "methods",\n      "where": [\n        {\n          "constraint": "signature_match",\n          "parent": "Lcom/facebook/marianatrench/integrationtests/AnnotationFeature;",\n          "name": "getSourceWithMethodAnnotation"\n        }\n      ],\n      "model": {\n        "generations": [\n          {\n            "kind": "Source",\n            "port": "Return",\n            "via_annotation": [\n              {\n                "type": "Lcom/facebook/marianatrench/integrationtests/Path;",\n                "target": "Return"\n              }\n            ]\n          }\n        ]\n      }\n    },\n    {\n      "find": "methods",\n      "where": [\n        {\n          "constraint": "signature_match",\n          "parent": "Lcom/facebook/marianatrench/integrationtests/AnnotationFeature;",\n          "name": "getSourceWithParameterAnnotation"\n        }\n      ],\n      "model": {\n        "generations": [\n          {\n            "kind": "Source",\n            "port": "Return",\n            "via_annotation": [\n              {\n                "type": "Lcom/facebook/marianatrench/integrationtests/QueryParam;",\n                "target": "Argument(1)"\n              },\n              {\n                "type": "Lcom/facebook/marianatrench/integrationtests/OtherQueryParam;",\n                "target": "Argument(2)",\n                "tag": "ParameterNameLabel",\n                "annotation_parameter": "description"\n              }\n            ]\n          }\n        ]\n      }\n    }\n  ]\n}\n')),(0,i.mdx)("p",null,"Java class with annotations:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},'public class AnnotationFeature {\n\n  @Path("/issue_1")\n  Object getSourceWithMethodAnnotation() {\n    return new Object();\n  }\n\n  Object getSourceWithParameterAnnotation(@QueryParam("query_param_name") String value, @OtherQueryParam(value = "other_query_param_name", description = "other_query_param_name_description") String description) {\n    return "unrelated";\n  }\n\n  void testSourceWithMethodAnnotation() {\n    Object source = getSourceWithMethodAnnotation();\n    Origin.sink(source);\n  }\n\n  void testSourceWithParameterAnnotation() {\n    Object source = getSourceWithParameterAnnotation("argument_value");\n    Origin.sink(source);\n  }\n}\n')),(0,i.mdx)("p",null,"Resulting issues:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "issues" :\n  [\n    {\n      "always_features" :\n      [\n        "via-annotation:/issue_1"\n      ],\n      "callee" : "Lcom/facebook/marianatrench/integrationtests/Origin;.sink:(Ljava/lang/Object;)V",\n...\n{\n  "issues" :\n  [\n    {\n      "always_features" :\n      [\n        "via-ParameterNameLabel-annotation:description_instead_of_value"\n      ],\n      "callee" : "Lcom/facebook/marianatrench/integrationtests/Origin;.sink:(Ljava/lang/Object;)V",\n...\n')),(0,i.mdx)("h3",{id:"taint-broadening"},"Taint Broadening"),(0,i.mdx)("p",null,(0,i.mdx)("strong",{parentName:"p"},"Taint broadening")," (also called ",(0,i.mdx)("strong",{parentName:"p"},"collapsing"),") happens when Mariana Trench needs to make an approximation about a taint flow. It is the operation of reducing a ",(0,i.mdx)("strong",{parentName:"p"},"taint tree")," into a single element. A ",(0,i.mdx)("strong",{parentName:"p"},"taint tree")," is a tree where edges are field names and nodes are taint element. This is how Mariana Trench represents internally which fields (or sequence of fields) are tainted."),(0,i.mdx)("p",null,"For instance, analyzing the following code:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},"MyClass var = new MyClass();\nvar.a = sourceX();\nvar.b.c = sourceY();\nvar.b.d = sourceZ();\n")),(0,i.mdx)("p",null,"The taint tree of variable ",(0,i.mdx)("inlineCode",{parentName:"p"},"var")," would be:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"      .\n  a /   \\ b\n { X }    .\n       c / \\ d\n     { Y }  { Z }\n")),(0,i.mdx)("p",null,"After collapsing, the tree is reduced to a single node ",(0,i.mdx)("inlineCode",{parentName:"p"},"{ X, Y, Z }"),", which is less precise."),(0,i.mdx)("p",null,"In conclusion, taint broadening effectively leads to considering the whole object as tainted while only some specific fields were initially tainted. This might happen for the correctness of the analysis or for performance reasons."),(0,i.mdx)("p",null,"In the following sections, we will discuss when collapsing can happen. In most cases, a feature is automatically added on collapsed taint to help detect false positives."),(0,i.mdx)("h4",{id:"propagation-broadening"},"Propagation Broadening"),(0,i.mdx)("p",null,"Taint collapsing is applied when taint is propagated through a method."),(0,i.mdx)("p",null,"For instance:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},"MyClass input = new MyClass();\ninput.a = SourceX();\nMyClass output = SomeClass.UnknownMethod(input);\nSink(output.b); // Considered an issue since `output` is considered tainted. This could be a False Negative without collapsing.\n")),(0,i.mdx)("p",null,"In that case, the ",(0,i.mdx)("a",{parentName:"p",href:"#feature"},"feature")," ",(0,i.mdx)("inlineCode",{parentName:"p"},"via-propagation-broadening")," will be automatically added on the taint. This can help identify false positives."),(0,i.mdx)("p",null,"If you know that this method ",(0,i.mdx)("strong",{parentName:"p"},"preserves the structure")," of the parameter, you could specify a model and disable collapsing using the ",(0,i.mdx)("inlineCode",{parentName:"p"},"collapse")," attribute within a ",(0,i.mdx)("a",{parentName:"p",href:"#propagation"},(0,i.mdx)("inlineCode",{parentName:"a"},"propagation")),":"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "find": "methods",\n  "where": [\n    {\n      "constraint": "signature_match",\n      "parent": "Lcom/example/SomeClass",\n      "name": "UnknownMethod"\n    }\n  ],\n  "model": {\n    "propagation": [\n      {\n        "input": "Argument(0)",\n        "output": "Return",\n        "collapse": false\n      }\n    ]\n  }\n}\n')),(0,i.mdx)("p",null,"Note that Mariana Trench can usually infer when a method propagates taint without collapsing it when it has access to the code of that method and subsequent calls. For instance:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},"public String identity(String x) {\n  // Automatically infers a propagation `Arg(0) -> Return` with `collapse=false`\n  return x;\n}\n")),(0,i.mdx)("h5",{id:"issue-broadening-feature"},"Issue Broadening Feature"),(0,i.mdx)("p",null,"The ",(0,i.mdx)("inlineCode",{parentName:"p"},"via-issue-broadening")," feature is added to issues where the taint flowing into the sink was not held directly on the object passed in but on one of its fields. For example:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},"Class input = new Class();\ninput.field = source();\nsink(input); // `input` is not tainted, but `input.field` is tainted and creates an issue\n")),(0,i.mdx)("h5",{id:"widen-broadening-feature"},"Widen Broadening Feature"),(0,i.mdx)("p",null,"For performance reasons, if a given taint tree becomes very large (either in depth or in number of nodes at a given level), Mariana Trench collapses the tree to a smaller size. In these cases, the ",(0,i.mdx)("inlineCode",{parentName:"p"},"via-widen-broadening")," feature is added to the collapsed taint"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},"Class input = new Class();\nif (\\* condition *\\) {\n  input.field1 = source();\n  input.field2 = source();\n  ...\n} else {\n  input.fieldA = source();\n  input.fieldB = source();\n  ...\n}\nsink(input); // Too many fields are sources so the whole input object becomes tainted\n")),(0,i.mdx)("h3",{id:"sanitizers"},"Sanitizers"),(0,i.mdx)("p",null,"Specifying sanitizers on a model allow us to stop taint flowing through that method. In Mariana Trench, they can be one of three types -"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"sources"),": prevent any taint sources from flowing out of the method"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"sinks"),": prevent taint from reaching any sinks within the method"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"propagations"),": prevent propagations from being inferred between any two ports of the method.")),(0,i.mdx)("p",null,"These can be specified in model generators as follows -"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "find": "methods",\n  "where": ...,\n  "model": {\n    "sanitizers": [\n      {\n        "sanitize": "sources"\n      },\n      {\n        "sanitize": "sinks"\n      },\n      {\n        "sanitize": "propagations"\n      }\n    ],\n    ...\n  }\n}\n')),(0,i.mdx)("p",null,"Note, if there are any user-specified sources, sinks or propagations on the model, sanitizers will not affect them, but it will prevent them from being propagated outward to callsites."),(0,i.mdx)("h4",{id:"kind-specific-sanitizers"},"Kind-specific Sanitizers"),(0,i.mdx)("p",null,(0,i.mdx)("inlineCode",{parentName:"p"},"sources")," and ",(0,i.mdx)("inlineCode",{parentName:"p"},"sinks")," sanitizers may include a list of kinds (each with or without a partial_label) to restrict the sanitizer to only sanitizing taint of those kinds. (When unspecified, as in the example above, all taint is sanitized regardless of kind)."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'"sanitizers": [\n  {\n    "sanitize": "sinks",\n    "kinds": [\n      {\n        "kind": "SinkKindA"\n      },\n      {\n        "kind": "SinkKindB",\n        "partial_label": "A"\n      }\n    ]\n  }\n]\n')),(0,i.mdx)("h4",{id:"port-specific-sanitizers"},"Port-specific Sanitizers"),(0,i.mdx)("p",null,"Sanitizers can also specify a specific port (",(0,i.mdx)("a",{parentName:"p",href:"/docs/models#access-path-format"},"access path")," root) they sanitize (ignoring all the rest). This field ",(0,i.mdx)("inlineCode",{parentName:"p"},"port")," has a slightly different meaning for each kind of sanitizer -"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"sources"),": represents the output port through which sources may not leave the method"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"sinks"),": represents the input port through which taint may not trigger any sinks within the model"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"propagations"),": represents the input port through which a propagation to any other port may not be inferred")),(0,i.mdx)("p",null,"For example if the following method"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},"public void someMethod(Object argument1, Object argument2) {\n  toSink(argument1);\n  toSink(argument2);\n}\n")),(0,i.mdx)("p",null,"had the following sanitizer in its model,"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'"sanitizers": [\n  {\n    "sanitize": "sinks",\n    "port": "Argument(1)"\n  }\n]\n')),(0,i.mdx)("p",null,"Then a source flowing into ",(0,i.mdx)("inlineCode",{parentName:"p"},"argument1")," would be able to cause an issue, but not a source flowing into ",(0,i.mdx)("inlineCode",{parentName:"p"},"argument2"),"."),(0,i.mdx)("p",null,"Kind and port specifications may be included in the same sanitizer."),(0,i.mdx)("h3",{id:"modes"},"Modes"),(0,i.mdx)("p",null,"Modes are used to describe specific behaviors of methods. Available modes are:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"skip-analysis"),": skip the analysis of the method;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"add-via-obscure-feature"),": add a feature/breadcrumb called ",(0,i.mdx)("inlineCode",{parentName:"li"},"via-obscure:<method>")," to sources flowing through this method;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"taint-in-taint-out"),": propagate the taint on arguments to the return value;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"taint-in-taint-this"),": propagate the taint on arguments into the ",(0,i.mdx)("inlineCode",{parentName:"li"},"this")," parameter;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"no-join-virtual-overrides"),": do not consider all possible overrides when handling a virtual call to this method;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"no-collapse-on-propagation"),": do not collapse input paths when applying propagations;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"alias-memory-location-on-invoke"),": aliases existing memory location at the callsite instead of creating a new one;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"strong-write-on-propagation"),": performs a strong write from input path to the output path on propagation;")),(0,i.mdx)("h3",{id:"default-model"},"Default model"),(0,i.mdx)("p",null,"A default model is created for each method, except if it is provided by a model generator. The default model has a set of heuristics:"),(0,i.mdx)("p",null,"If the method has no source code, the model is automatically marked with the modes ",(0,i.mdx)("inlineCode",{parentName:"p"},"skip-analysis")," and ",(0,i.mdx)("inlineCode",{parentName:"p"},"add-via-obscure-feature"),"."),(0,i.mdx)("p",null,"If the method has more than 40 overrides, it is marked with the mode ",(0,i.mdx)("inlineCode",{parentName:"p"},"no-join-virtual-overrides"),"."),(0,i.mdx)("p",null,"Otherwise, the default model is empty (no sources/sinks/propagations)."),(0,i.mdx)("h3",{id:"field-models"},"Field Models"),(0,i.mdx)("p",null,"These models represent user-defined taint on class fields (as opposed to methods, as described in all the previous sections on this page). They are specified in a similar way to method models as described below."),(0,i.mdx)("blockquote",null,(0,i.mdx)("p",{parentName:"blockquote"},(0,i.mdx)("strong",{parentName:"p"},"NOTE:")," Field sources should not be applied to fields that are both final and of a primitive type (",(0,i.mdx)("inlineCode",{parentName:"p"},"int"),", ",(0,i.mdx)("inlineCode",{parentName:"p"},"char"),", ",(0,i.mdx)("inlineCode",{parentName:"p"},"float"),", etc as well as ",(0,i.mdx)("inlineCode",{parentName:"p"},"java.lang.String"),") as the Java compiler optimizes accesses of these fields in the bytecode into accesses of the constant value they hold. In this scenario, Mariana Trench has no way of recognizing that the constant was meant to carry a source.")),(0,i.mdx)("p",null,"Example field model generator for sources:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "find": "fields",\n  "where": [\n    {\n      "constraint": "name",\n      "pattern": "SOURCE_EXAMPLE"\n    }\n  ],\n  "model": {\n    "sources" : [\n      {\n        "kind": "FieldSource"\n      }\n    ]\n  }\n}\n')),(0,i.mdx)("p",null,"Example code:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},"public class TestClass {\n  // Field that we know to be tainted\n  public Object SOURCE_EXAMPLE = ...;\n\n  void flow() {\n    sink(EXAMPLE, ...);\n  }\n}\n")),(0,i.mdx)("p",null,"Example field model generator for sinks:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "find": "fields",\n  "where": [\n    {\n      "constraint": "name",\n      "pattern": "SINK_EXAMPLE"\n    }\n  ],\n  "model": {\n    "sinks" : [\n      {\n        "kind": "FieldSink"\n      }\n    ]\n  }\n}\n')),(0,i.mdx)("p",null,"Example code:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},"public class TestClass {\n  public Object SINK_EXAMPLE = ...;\n\n  void flow() {\n    SINK_EXAMPLE = source();\n  }\n}\n")),(0,i.mdx)("p",null,"Field signature formats follow the Dalvik bytecode format similar to methods as discussed ",(0,i.mdx)("a",{parentName:"p",href:"#method-name-format"},"above"),". This is of the form ",(0,i.mdx)("inlineCode",{parentName:"p"},"<className>.<fieldName>:<fieldType>"),"."),(0,i.mdx)("h3",{id:"literal-models"},"Literal Models"),(0,i.mdx)("p",null,"Literal models represent user-defined taints on string literals matching configurable regular expressions. They can only be configured as sources and are intended to identify suspicious patterns, such as user-controlled data being concatenated with a string literal which looks like an SQL query."),(0,i.mdx)("blockquote",null,(0,i.mdx)("p",{parentName:"blockquote"},(0,i.mdx)("strong",{parentName:"p"},"NOTE:")," Each use of a literal in the analysed code which matches a pattern in a literal model will generate a new taint which needs to be explored by Mariana Trench. Using overly broad patterns like ",(0,i.mdx)("inlineCode",{parentName:"p"},".*")," should thus be avoided, as they can lead to poor performance and high memory usage.")),(0,i.mdx)("p",null,"Example literal models:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},'[\n  {\n    "pattern": "SELECT \\\\*.*",\n    "description": "Potential SQL Query",\n    "sources": [\n      {\n        "kind": "SqlQuery"\n      }\n    ]\n  },\n  {\n    "pattern": "AI[0-9A-Z]{16}",\n    "description": "Suspected Google API Key",\n    "sources": [\n      {\n        "kind": "GoogleAPIKey"\n      }\n    ]\n  }\n]\n')),(0,i.mdx)("p",null,"Example code:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},'void testRegexSource() {\n  String prefix = "SELECT * FROM USERS WHERE id = ";\n  String aci = getAttackerControlledInput();\n  String query = prefix + aci; // Sink\n}\n\nvoid testRegexSourceGoogleApiKey() {\n  String secret = "AIABCD1234EFGH5678";\n  sink(secret);\n}\n')),(0,i.mdx)("h2",{id:"model-generators"},"Model Generators"),(0,i.mdx)("p",null,"Mariana Trench allows for dynamic model specifications. This allows a user to specify models of methods before running the analysis. This is used to specify sources, sinks, propagation and modes."),(0,i.mdx)("p",null,"The model generator files must have the extension ",(0,i.mdx)("inlineCode",{parentName:"p"},".models"),". The locations to search for these files must be provided using the ",(0,i.mdx)("inlineCode",{parentName:"p"},"--model-generator-search-paths")," argument."),(0,i.mdx)("p",null,"Model generators to use during analysis are listed in a ",(0,i.mdx)("em",{parentName:"p"},"model generator configuration file")," and specified using the ",(0,i.mdx)("inlineCode",{parentName:"p"},"--model-generator-configuration-paths")," argument. By default, we use ",(0,i.mdx)("a",{parentName:"p",href:"https://github.com/facebook/mariana-trench/blob/main/configuration/default_generator_config.json"},(0,i.mdx)("inlineCode",{parentName:"a"},"default_generator_config.json")),". Any other ",(0,i.mdx)("inlineCode",{parentName:"p"},".models")," files found in the search paths but not listed in the configuration file are ignored."),(0,i.mdx)("h3",{id:"example"},"Example"),(0,i.mdx)("p",null,"Examples of model generators are located in the ",(0,i.mdx)("a",{parentName:"p",href:"https://github.com/facebook/mariana-trench/tree/main/configuration/model-generators"},(0,i.mdx)("inlineCode",{parentName:"a"},"configuration/model-generators"))," directory."),(0,i.mdx)("p",null,"Below is an example of a JSON model generator:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "model_generators": [\n    {\n      "find": "methods",\n      "where": [{"constraint": "name", "pattern": "toString"}],\n      "model": {\n        "propagation": [\n          {\n            "input": "Argument(0)",\n            "output": "Return"\n          }\n        ]\n      }\n    },\n    {\n      "find": "methods",\n      "where": [\n        {\n          "constraint": "parent",\n          "inner": {\n            "constraint": "extends",\n            "inner": {\n              "constraint": "name",\n              "pattern": "SandcastleCommand"\n            }\n          }\n        },\n        {"constraint": "name", "pattern": "Time"}\n      ],\n      "model": {\n        "sources": [\n          {\n            "kind": "Source",\n            "port": "Return"\n          }\n        ]\n      }\n    },\n    {\n      "find": "methods",\n      "where": [\n        {\n          "constraint": "parent",\n          "inner": {\n            "constraint": "extends",\n            "inner": {"constraint": "name", "pattern": "IEntWithPurposePolicy"}\n          }\n        },\n        {"constraint": "name", "pattern": "gen.*"},\n        {\n          "constraint": "parameter",\n          "idx": 0,\n          "inner": {\n            "constraint": "type",\n            "kind": "extends",\n            "class": "IViewerContext"\n          }\n        },\n        {\n          "constraint": "return",\n          "inner": {\n            "constraint": "extends",\n            "inner": {"constraint": "name", "pattern": "Ent"}\n          }\n        }\n      ],\n      "model": {\n        "modes": ["add-via-obscure-feature"],\n        "sinks": [\n          {\n            "kind": "Sink",\n            "port": "Argument(0)",\n            "features": ["via-gen"]\n          }\n        ]\n      }\n    }\n  ]\n}\n')),(0,i.mdx)("h3",{id:"specification"},"Specification"),(0,i.mdx)("p",null,"Each JSON file is a JSON object with a key ",(0,i.mdx)("inlineCode",{parentName:"p"},"model_generators"),' associated with a list of "rules".'),(0,i.mdx)("p",null,'Each "rule" defines a "filter" (which uses "constraints" to specify methods for which a "model" should be generated) and a "model". A rule has the following key/values:'),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("inlineCode",{parentName:"p"},"find"),": The type of thing to find. We support ",(0,i.mdx)("inlineCode",{parentName:"p"},"methods")," and ",(0,i.mdx)("inlineCode",{parentName:"p"},"fields"),";")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("inlineCode",{parentName:"p"},"where"),': A list of "constraints". All constraints ',(0,i.mdx)("strong",{parentName:"p"},"must be satisfied")," by a method or field in order to generate a model for it. All the constraints are listed below, grouped by the type of object they are applied to:"),(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("strong",{parentName:"p"},"Method"),":"),(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"signature_match"),": Expects at least one of the two allowed groups of extra properties: ",(0,i.mdx)("inlineCode",{parentName:"li"},"[name | names] [parent | parents | extends [include_self]]")," where:",(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"name")," (a single string) or ",(0,i.mdx)("inlineCode",{parentName:"li"},"names")," (a list of alternative strings): is exact matched to the method name"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"parent")," (a single string) or ",(0,i.mdx)("inlineCode",{parentName:"li"},"parents")," (a list of alternative strings) is exact matched to the class of the method or ",(0,i.mdx)("inlineCode",{parentName:"li"},"extends")," (either a single string or a list of alternative strings) is exact matched to the base classes or interfaces of the method. ",(0,i.mdx)("inlineCode",{parentName:"li"},"extends")," allows an optional property ",(0,i.mdx)("inlineCode",{parentName:"li"},"include_self")," which is a boolean to indicate if the constraint is applied to the class itself or not (defaults to ",(0,i.mdx)("inlineCode",{parentName:"li"},"true"),")."))),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"signature | signature_pattern"),": Expects an extra property ",(0,i.mdx)("inlineCode",{parentName:"li"},"pattern")," which is a regex (with appropriate escaping) to fully match the full signature (class, method, argument types) of a method;",(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("strong",{parentName:"li"},"NOTE:")," Usage of this constraint is discouraged as it has poor performance. Try using ",(0,i.mdx)("inlineCode",{parentName:"li"},"signature_match")," instead! (Exception: Performance does not suffer if the entire method signature is exactly as specified in ",(0,i.mdx)("inlineCode",{parentName:"li"},"pattern"),". This provides an easy way to match full signatures with parameter and return types)"))),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"parent"),": Expects an extra property ",(0,i.mdx)("inlineCode",{parentName:"li"},"inner")," ","[Type]"," which contains a nested constraint to apply to the class holding the method;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"parameter"),": Expects an extra properties ",(0,i.mdx)("inlineCode",{parentName:"li"},"idx")," and ",(0,i.mdx)("inlineCode",{parentName:"li"},"inner")," ","[Parameter]"," or ","[Type]",", matches when the idx-th parameter of the function or method matches the nested constraint inner;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"any_parameter"),": Expects an optional extra property ",(0,i.mdx)("inlineCode",{parentName:"li"},"start_idx")," and ",(0,i.mdx)("inlineCode",{parentName:"li"},"inner")," ","[Parameter]"," or ","[Type]",", matches when there is any parameters (starting at start_idx) of the function or method matches the nested constraint inner;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"return"),": Expects an extra property ",(0,i.mdx)("inlineCode",{parentName:"li"},"inner")," ","[Type]"," which contains a nested constraint to apply to the return of the method;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"is_static | is_constructor | is_native | has_code"),": Accepts an extra property ",(0,i.mdx)("inlineCode",{parentName:"li"},"value")," which is either ",(0,i.mdx)("inlineCode",{parentName:"li"},"true")," or ",(0,i.mdx)("inlineCode",{parentName:"li"},"false"),". By default, ",(0,i.mdx)("inlineCode",{parentName:"li"},"value")," is considered ",(0,i.mdx)("inlineCode",{parentName:"li"},"true"),";"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"number_parameters"),": Expects an extra property ",(0,i.mdx)("inlineCode",{parentName:"li"},"inner")," ","[Integer]"," which contains a nested constraint to apply to the number of parameters (counting the implicit ",(0,i.mdx)("inlineCode",{parentName:"li"},"this")," parameter);"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"number_overrides"),": Expects an extra property ",(0,i.mdx)("inlineCode",{parentName:"li"},"inner")," ","[Integer]"," which contains a nested constraint to apply on the number of method overrides."))),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("strong",{parentName:"p"},"Parameter:")),(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"parameter_has_annotation"),": Expects an extra property ",(0,i.mdx)("inlineCode",{parentName:"li"},"type")," and an optional property ",(0,i.mdx)("inlineCode",{parentName:"li"},"pattern"),", respectively a string and a regex fully matching the value of the parameter annotation."))),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("strong",{parentName:"p"},"Type:")),(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"extends"),": Expects an extra property ",(0,i.mdx)("inlineCode",{parentName:"li"},"inner")," ","[Type]"," which contains a nested constraint that must apply to one of the base classes or itself. The optional property ",(0,i.mdx)("inlineCode",{parentName:"li"},"include_self")," is a boolean that tells whether the constraint must be applied on the type itself or not (defaults to ",(0,i.mdx)("inlineCode",{parentName:"li"},"true"),");"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"super"),": Expects an extra property ",(0,i.mdx)("inlineCode",{parentName:"li"},"inner")," ","[Type]"," which contains a nested constraint that must apply on the direct superclass;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"is_class | is_interface"),": Accepts an extra property ",(0,i.mdx)("inlineCode",{parentName:"li"},"value")," which is either ",(0,i.mdx)("inlineCode",{parentName:"li"},"true")," or ",(0,i.mdx)("inlineCode",{parentName:"li"},"false"),". By default, ",(0,i.mdx)("inlineCode",{parentName:"li"},"value")," is considered ",(0,i.mdx)("inlineCode",{parentName:"li"},"true"),";"))),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("strong",{parentName:"p"},"Field"),":"),(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"signature"),": Expects an extra property ",(0,i.mdx)("inlineCode",{parentName:"li"},"pattern")," which is a regex to fully match the full signature of the field. This is of the form ",(0,i.mdx)("inlineCode",{parentName:"li"},"<className>.<fieldName>:<fieldType>"),";"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"parent"),": Expects an extra property ",(0,i.mdx)("inlineCode",{parentName:"li"},"inner")," ","[Type]"," which contains a nested constraint to apply to the class holding the field;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"is_static"),": Accepts an extra property ",(0,i.mdx)("inlineCode",{parentName:"li"},"value")," which is either ",(0,i.mdx)("inlineCode",{parentName:"li"},"true")," or ",(0,i.mdx)("inlineCode",{parentName:"li"},"false"),". By default, ",(0,i.mdx)("inlineCode",{parentName:"li"},"value")," is considered ",(0,i.mdx)("inlineCode",{parentName:"li"},"true"),";"))),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("strong",{parentName:"p"},"Method, Type or Field:")),(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"name"),": Expects an extra property ",(0,i.mdx)("inlineCode",{parentName:"li"},"pattern")," which is a regex to fully match the name of the item;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"has_annotation"),": Expects an extra property ",(0,i.mdx)("inlineCode",{parentName:"li"},"type")," and an optional property ",(0,i.mdx)("inlineCode",{parentName:"li"},"pattern"),", respectively a string and a regex fully matching the value of the annotation."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"visibility"),": Expects an extra property ",(0,i.mdx)("inlineCode",{parentName:"li"},"is")," which is either ",(0,i.mdx)("inlineCode",{parentName:"li"},"public"),", ",(0,i.mdx)("inlineCode",{parentName:"li"},"private")," or ",(0,i.mdx)("inlineCode",{parentName:"li"},"protected"),"; (Note this does not apply to ",(0,i.mdx)("inlineCode",{parentName:"li"},"Field"),")"))),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("strong",{parentName:"p"},"Integer:")),(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"< | <= | == | > | >= | !="),": Expects an extra property ",(0,i.mdx)("inlineCode",{parentName:"li"},"value")," which contains an integer that the input integer is compared with. The input is the left hand side."))),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("strong",{parentName:"p"},"Any (Method, Parameter, Type, Field or Integer):")),(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"all_of"),": Expects an extra property ",(0,i.mdx)("inlineCode",{parentName:"li"},"inners")," ","[Any]"," which is an array holding nested constraints which must all apply;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"any_of"),": Expects an extra property ",(0,i.mdx)("inlineCode",{parentName:"li"},"inners")," ","[Any]"," which is an array holding nested constraints where one of them must apply;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"not"),": Expects an extra property ",(0,i.mdx)("inlineCode",{parentName:"li"},"inner")," ","[Any]"," which contains a nested constraint that should not apply. (Note this is not yet implemented for ",(0,i.mdx)("inlineCode",{parentName:"li"},"Field"),"s)"))))),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("inlineCode",{parentName:"p"},"model"),": A model, describing sources/sinks/propagations/etc."),(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("strong",{parentName:"p"},"For method models")),(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"sources"),"*",": A list of sources, i.e a source ",(0,i.mdx)("em",{parentName:"li"},"flowing out")," of the method via return value or ",(0,i.mdx)("em",{parentName:"li"},"flowing in")," via an argument. To specify sources ",(0,i.mdx)("em",{parentName:"li"},"flowing out")," via an argument, specify it as ",(0,i.mdx)("inlineCode",{parentName:"li"},"generations"),". A source/generation has the following key/values:",(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"kind"),": The source name;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"port"),"*","*",": The source access path (e.g, ",(0,i.mdx)("inlineCode",{parentName:"li"},'"Return"')," or ",(0,i.mdx)("inlineCode",{parentName:"li"},'"Argument(1)"'),");"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"features"),"*",": A list of features/breadcrumbs names;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"via_type_of"),"*",": A list of ports;"))),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"sinks"),"*",": A list of sinks, i.e describing that a parameter of the method flows into a sink. A sink has the following key/values:",(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"kind"),": The sink name;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"port"),": The sink access path (e.g, ",(0,i.mdx)("inlineCode",{parentName:"li"},'"Return"')," or ",(0,i.mdx)("inlineCode",{parentName:"li"},'"Argument(1)"'),");"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"features"),"*",": A list of features/breadcrumbs names;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"via_type_of"),"*",": A list of ports;"))),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"propagation"),"*",": A list of propagations (also called passthrough) that describe whether a taint on a parameter should result in a taint on the return value or another parameter. A propagation has the following key/values:",(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"input"),": The input access path (e.g, ",(0,i.mdx)("inlineCode",{parentName:"li"},'"Argument(1)"'),");"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"output"),": The output access path (e.g, ",(0,i.mdx)("inlineCode",{parentName:"li"},'"Return"')," or ",(0,i.mdx)("inlineCode",{parentName:"li"},'"Argument(2)"'),");"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"features"),"*",": A list of features/breadcrumbs names;"))),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"attach_to_sources"),"*",": A list of attach-to-sources that describe that all sources flowing out of the method on the given parameter or return value must have the given features. An attach-to-source has the following key/values:",(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"port"),": The access path root (e.g, ",(0,i.mdx)("inlineCode",{parentName:"li"},'"Return"')," or ",(0,i.mdx)("inlineCode",{parentName:"li"},'"Argument(1)"'),");"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"features"),": A list of features/breadcrumb names;"))),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"attach_to_sinks"),"*",": A list of attach-to-sinks that describe that all sources flowing in the method on the given parameter must have the given features. An attach-to-sink has the following key/values:",(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"port"),": The access path root (e.g, ",(0,i.mdx)("inlineCode",{parentName:"li"},'"Argument(1)"'),");"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"features"),": A list of features/breadcrumb names;"))),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"attach_to_propagations"),"*",": A list of attach-to-propagations that describe that inferred propagations of sources flowing in or out of a given parameter or return value must have the given features. An attach-to-propagation has the following key/values:",(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"port"),": The access path root (e.g, ",(0,i.mdx)("inlineCode",{parentName:"li"},'"Return"')," or ",(0,i.mdx)("inlineCode",{parentName:"li"},'"Argument(1)"'),");"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"features"),": A list of features/breadcrumb names;"))),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"add_features_to_parameters"),"*",": A list of add-features-to-parameters that describe that flows that might flow on the given parameter must have the given features. An add-features-to-parameter has the following key/values:",(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"port"),": The access path root (e.g, ",(0,i.mdx)("inlineCode",{parentName:"li"},'"Argument(1)"'),");"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"features"),": A list of features/breadcrumb names;"))),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"modes"),"*",": A list of mode names that describe specific behaviors of a method;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"for_all_parameters"),": Generate sources/sinks/propagations/attach",(0,i.mdx)("em",{parentName:"li"},"to"),"*"," for all parameters of a method that satisfy some constraints. It accepts the following key/values:",(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"variable"),": A symbolic name for the parameter;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"where"),": An optional list of ","[Parameter]"," or ","[Type]"," constraints on the parameter;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"sources | sinks | propagation"),': Same as under "model", but we accept the variable name as a parameter number.'))))),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("inlineCode",{parentName:"p"},"verbosity"),"*",": A logging level, to help debugging. 1 is the most verbose, 5 is the least. The default verbosity level is 5.")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},(0,i.mdx)("strong",{parentName:"p"},"For Field models")),(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"sources"),"*",": A list of sources the field should hold. A source has the following key/values:",(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"kind"),": The source name;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"features"),"*",": A list of features/breadcrumbs names;"))),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"sinks"),"*",": A list of sinks the field should hold. A sink has the following key/values:",(0,i.mdx)("ul",{parentName:"li"},(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"kind"),": The sink name;"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"features"),"*",": A list of features/breadcrumbs names;")))))))),(0,i.mdx)("p",null,"In the above bullets,"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"*")," denotes optional key/value."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"**")," denotes optional key/value. Default is ",(0,i.mdx)("inlineCode",{parentName:"li"},'"Return"'),".")),(0,i.mdx)("p",null,"Note, the implicit ",(0,i.mdx)("inlineCode",{parentName:"p"},"this")," parameter for methods has the parameter number 0."),(0,i.mdx)("h3",{id:"development"},"Development"),(0,i.mdx)("h4",{id:"when-sources-or-sinks-dont-appear-in-results"},"When Sources or Sinks don't appear in Results"),(0,i.mdx)("ol",null,(0,i.mdx)("li",{parentName:"ol"},(0,i.mdx)("p",{parentName:"li"},"This could be because your model generator did not find any method matching your query. You can use the ",(0,i.mdx)("inlineCode",{parentName:"p"},'"verbosity": 1')," option in your model generator to check if it matched any method. For instance:"),(0,i.mdx)("pre",{parentName:"li"},(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "model_generators": [\n    {\n      "find": "methods",\n      "where": /* ... */,\n      "model": {\n        /* ... */\n      },\n      "verbosity": 1\n    }\n  ]\n}\n')),(0,i.mdx)("p",{parentName:"li"},"When running mariana trench, this should print:"),(0,i.mdx)("pre",{parentName:"li"},(0,i.mdx)("code",{parentName:"pre"},"INFO Method `...` satisfies all constraints in json model generator ...\n"))),(0,i.mdx)("li",{parentName:"ol"},(0,i.mdx)("p",{parentName:"li"},"Make sure that your model generator is actually running. You can use the ",(0,i.mdx)("inlineCode",{parentName:"p"},"--verbosity 2")," option to check that. Make sure your model generator is specified in ",(0,i.mdx)("inlineCode",{parentName:"p"},"configuration/default_generator_config.json"),".")),(0,i.mdx)("li",{parentName:"ol"},(0,i.mdx)("p",{parentName:"li"},"You can also check the output models. Use ",(0,i.mdx)("inlineCode",{parentName:"p"},"grep SourceKind models@*")," to see if your source or sink kind exists. Use ",(0,i.mdx)("inlineCode",{parentName:"p"},"grep 'Lcom/example/<class-name>;.<method-name>:' models@*")," to see if a given method exists in the app."))),(0,i.mdx)(m,{mdxType:"FbModels"}))}c.isMDXComponent=!0}}]);
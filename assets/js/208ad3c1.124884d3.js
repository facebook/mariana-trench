"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[800],{3905:(e,n,t)=>{t.r(n),t.d(n,{MDXContext:()=>s,MDXProvider:()=>p,mdx:()=>h,useMDXComponents:()=>m,withMDXComponents:()=>c});var o=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(){return r=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var o in t)Object.prototype.hasOwnProperty.call(t,o)&&(e[o]=t[o])}return e},r.apply(this,arguments)}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function d(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,o,a=function(e,n){if(null==e)return{};var t,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=o.createContext({}),c=function(e){return function(n){var t=m(n.components);return o.createElement(e,r({},n,{components:t}))}},m=function(e){var n=o.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):d(d({},n),e)),t},p=function(e){var n=m(e.components);return o.createElement(s.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},g=o.forwardRef((function(e,n){var t=e.components,a=e.mdxType,r=e.originalType,i=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),c=m(t),p=a,g=c["".concat(i,".").concat(p)]||c[p]||u[p]||r;return t?o.createElement(g,d(d({ref:n},s),{},{components:t})):o.createElement(g,d({ref:n},s))}));function h(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var r=t.length,i=new Array(r);i[0]=g;var d={};for(var l in n)hasOwnProperty.call(n,l)&&(d[l]=n[l]);d.originalType=e,d.mdxType="string"==typeof e?e:a,i[1]=d;for(var s=2;s<r;s++)i[s]=t[s];return o.createElement.apply(null,i)}return o.createElement.apply(null,t)}g.displayName="MDXCreateElement"},74710:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>d,default:()=>g,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var o=t(87462),a=(t(67294),t(3905)),r=t(86341);const i={id:"debugging-fp-fns",title:"Debugging False Positives/False Negatives",sidebar_label:"Debugging False Positives/False Negatives"},d=void 0,l={unversionedId:"debugging-fp-fns",id:"debugging-fp-fns",title:"Debugging False Positives/False Negatives",description:"This document is mainly intended for software engineers, to help them debug false positives and false negatives.",source:"@site/documentation/debugging_fp_fns.md",sourceDirName:".",slug:"/debugging-fp-fns",permalink:"/docs/debugging-fp-fns",draft:!1,editUrl:"https://github.com/facebook/mariana-trench/tree/main/documentation/website/documentation/debugging_fp_fns.md",tags:[],version:"current",frontMatter:{id:"debugging-fp-fns",title:"Debugging False Positives/False Negatives",sidebar_label:"Debugging False Positives/False Negatives"},sidebar:"docs",previous:{title:"Build from Source",permalink:"/docs/build-from-source"}},s={},c=[{value:"Investigate the output models",id:"investigate-the-output-models",level:2},{value:"Example",id:"example",level:3},{value:"Investigating the transfer function",id:"investigating-the-transfer-function",level:2}],m=(p="FbDebugging",function(e){return console.warn("Component "+p+" was not imported, exported, or provided by MDXProvider as global scope"),(0,a.mdx)("div",e)});var p;const u={toc:c};function g(e){let{components:n,...t}=e;return(0,a.mdx)("wrapper",(0,o.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,a.mdx)("p",null,"This document is mainly intended for software engineers, to help them debug false positives and false negatives."),(0,a.mdx)(r.OssOnly,{mdxType:"OssOnly"},"## Setup",(0,a.mdx)("p",null,"First, you need to run the analysis on your computer. This will create ",(0,a.mdx)("inlineCode",{parentName:"p"},"model@XXX.json")," files in the current directory, containing the results of the analysis.")),(0,a.mdx)(r.FbInternalOnly,{mdxType:"FbInternalOnly"}," ",(0,a.mdx)(m,{mdxType:"FbDebugging"})," "),(0,a.mdx)("h2",{id:"investigate-the-output-models"},"Investigate the output models"),(0,a.mdx)("p",null,"Now, your objective is to understand in which method we lost the flow (false negative) or introduced the invalid flow (false positive). You will need to look into the output models for that. I recommend to use the ",(0,a.mdx)("inlineCode",{parentName:"p"},"explore_models.py")," bento script."),(0,a.mdx)("p",null,"Run the following command in the directory containing the output model files (i.e, ",(0,a.mdx)("inlineCode",{parentName:"p"},"model@XXX.json"),"):"),(0,a.mdx)(r.OssOnly,{mdxType:"OssOnly"},(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-shell"},"python3 -i mariana_trench_repository/scripts/explore_models.py\n"))),(0,a.mdx)(r.FbInternalOnly,{mdxType:"FbInternalOnly"},(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-shell"},"bento console -i --file ~/fbsource/fbandroid/native/mariana-trench/scripts/explore_models.py\n"))),(0,a.mdx)("p",null,"This provides you with a few helper functions:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-shell"},"  index('.')                    Index all available models in the given directory.\n  method_containing('Foo;.bar') Find all methods containing the given string.\n  method_matching('Foo.*')      Find all methods matching the given regular expression.\n  get_model('Foo;.bar')         Get the model for the given method.\n  print_model('Foo;.bar')       Pretty print the model for the given method.\n")),(0,a.mdx)("p",null,"Use ",(0,a.mdx)("inlineCode",{parentName:"p"},"index")," to index all models first:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-shell"},"In [1]: index()\n")),(0,a.mdx)("p",null,"Now you can search for methods with ",(0,a.mdx)("inlineCode",{parentName:"p"},"method_containing")," and print their models with ",(0,a.mdx)("inlineCode",{parentName:"p"},"print_model"),".\nYou probably want to look at the first or last frame of the trace, to see if the source or sink is present. Then, you will want to follow the frames until you find the problematic method."),(0,a.mdx)("h3",{id:"example"},"Example"),(0,a.mdx)("p",null,"Let's suppose I am investigating a false negative, I want to find in which method we are losing the flow. I could start looking at the last frame, i.e the sink:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-shell"},'In [2]: method_containing(\'Landroid/content/Context;.sendOrderedBroadcast\')\nOut[2]:\n[\'Landroid/content/Context;.sendOrderedBroadcast:(Landroid/content/Intent;Ljava/lang/String;)V\',\n \'Landroid/content/Context;.sendOrderedBroadcast:(Landroid/content/Intent;Ljava/lang/String;Landroid/content/BroadcastReceiver;Landroid/os/Handler;ILjava/lang/String;Landroid/os/Bundle;)V\',\n \'Landroid/content/Context;.sendOrderedBroadcastAsUser:(Landroid/content/Intent;Landroid/os/UserHandle;Ljava/lang/String;Landroid/content/BroadcastReceiver;Landroid/os/Handler;ILjava/lang/String;Landroid/os/Bundle;)V\']\n\nIn [3]: print_model(\'Landroid/content/Context;.sendOrderedBroadcast:(Landroid/content/Intent;Ljava/lang/String;Landroid/content/BroadcastReceiver;Landroid/os/Handler;ILjava/lang/String;Landroid/os/Bundle;)V\')\n{\n  "method": "Landroid/content/Context;.sendOrderedBroadcast:(Landroid/content/Intent;Ljava/lang/String;Landroid/content/BroadcastReceiver;Landroid/os/Handler;ILjava/lang/String;Landroid/os/Bundle;)V",\n  "modes": [\n    "skip-analysis",\n    "add-via-obscure-feature",\n    "taint-in-taint-out",\n    "taint-in-taint-this",\n    "no-join-virtual-overrides"\n  ],\n  "position": {\n    "path": "android/content/Context.java"\n  },\n  ...\n  "sinks": [\n    {\n      "callee_port": "Leaf",\n      "caller_port": "Argument(1)",\n      "kind": "LaunchingComponent",\n      "origins": [\n        "Landroid/content/Context;.sendOrderedBroadcast:(Landroid/content/Intent;Ljava/lang/String;Landroid/content/BroadcastReceiver;Landroid/os/Handler;ILjava/lang/String;Landroid/os/Bundle;)V"\n      ]\n    }\n  ]\n}\n')),(0,a.mdx)("p",null,"As expected, the method has a sink on Argument(1), so we are good for now. Next, I want to check the previous frame, which calls ",(0,a.mdx)("inlineCode",{parentName:"p"},"Context.sendOrderedBroadcast"),":"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-shell"},'In [2]: method_containing(\'ShortcutManagerCompat;.requestPinShortcut:\')\nOut[2]: [\'Landroidx/core/content/pm/ShortcutManagerCompat;.requestPinShortcut:(Landroid/content/Context;Landroidx/core/content/pm/ShortcutInfoCompat;Landroid/content/IntentSender;)Z\']\n\nIn [3]: print_model(\'Landroidx/core/content/pm/ShortcutManagerCompat;.requestPinShortcut:(Landroid/content/Context;Landroidx/core/content/pm/ShortcutInfoCompat;Landroid/content/IntentSender;)Z\')\n{\n  "method": "Landroidx/core/content/pm/ShortcutManagerCompat;.requestPinShortcut:(Landroid/content/Context;Landroidx/core/content/pm/ShortcutInfoCompat;Landroid/content/IntentSender;)Z",\n  "position": {\n    "line": 112,\n    "path": "androidx/core/content/pm/ShortcutManagerCompat.java"\n  },\n  ...\n  "sinks": [\n     ...\n    {\n      "always_features": [\n        "via-obscure",\n        "via-obscure-taint-in-taint-this",\n        "via-intent-extra",\n        "has-intent-extras"\n      ],\n      "call_position": {\n        "line": 130,\n        "path": "androidx/core/content/pm/ShortcutManagerCompat.java"\n      },\n      "callee": "Landroid/content/Context;.sendOrderedBroadcast:(Landroid/content/Intent;Ljava/lang/String;Landroid/content/BroadcastReceiver;Landroid/os/Handler;ILjava/lang/String;Landroid/os/Bundle;)V",\n      "callee_port": "Argument(1)",\n      "caller_port": "Argument(1).mIntents",\n      "distance": 1,\n      "kind": "LaunchingComponent",\n      "local_positions": [\n        {\n          "line": 121\n        }\n      ],\n      "origins": [\n        "Landroid/content/Context;.sendOrderedBroadcast:(Landroid/content/Intent;Ljava/lang/String;Landroid/content/BroadcastReceiver;Landroid/os/Handler;ILjava/lang/String;Landroid/os/Bundle;)V"\n      ]\n    }\n  ]\n}\n')),(0,a.mdx)("p",null,"I can see the frame from ",(0,a.mdx)("inlineCode",{parentName:"p"},"ShortcutManagerCompat.requestPinShortcut")," on ",(0,a.mdx)("inlineCode",{parentName:"p"},"Argument(1).mIntents")," to ",(0,a.mdx)("inlineCode",{parentName:"p"},"Context.sendOrderedBroadcast")," on ",(0,a.mdx)("inlineCode",{parentName:"p"},"Argument(1)"),". I can keep following frames until I find the method that misses a source or sink."),(0,a.mdx)("p",null,"For frames from the source to the root callable, I should look at ",(0,a.mdx)("inlineCode",{parentName:"p"},"generations"),", and for frames from the root callable to the sink, I should look at ",(0,a.mdx)("inlineCode",{parentName:"p"},"sinks"),". On the root callable, I should look at ",(0,a.mdx)("inlineCode",{parentName:"p"},"issues"),"."),(0,a.mdx)("h2",{id:"investigating-the-transfer-function"},"Investigating the transfer function"),(0,a.mdx)("p",null,"Once you know in which method you are losing the flow or introducing an invalid flow, you will need to run the analysis with logging enabled for that method, using:"),(0,a.mdx)(r.OssOnly,{mdxType:"OssOnly"},(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-shell"},"mariana-trench \\\n  --apk-path='your-apk' \\\n  --log-method='method-name'\n"))),(0,a.mdx)(r.FbInternalOnly,{mdxType:"FbInternalOnly"},(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-shell"},"buck run //fbandroid/native/mariana-trench/shim:shim -- \\\n  --apk-path='your-apk' \\\n  --log-method='method-name'\n"))),(0,a.mdx)("p",null,"This will log everything the transfer function does in that method, which might be a lot of logs. You can pipe this into a file or into ",(0,a.mdx)("inlineCode",{parentName:"p"},"less"),". Using logs, you should be able to see in which instruction you are losing the taint. Remember, the analysis computes a fixpoint, so the method will be analyzed multiple times. You should look at the last time it was analyzed (i.e, end of the logs)."),(0,a.mdx)("p",null,"Happy debugging!"))}g.isMDXComponent=!0}}]);
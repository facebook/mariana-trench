/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

package com.facebook.marianatrench.integrationtests;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;

class ExportedActivity extends Activity {
  private Object mSource;

  @Override
  protected void onCreate() {
    mSource = Origin.source();
    ExploitabilityRule.testExported(this);

    // Call so that both Exported and ExportedDfa are reachable where
    // distance(Exported) > distance(ExportedDfa)
    onDfaExported();
  }

  @Override
  protected void onStart() {
    // Issues reported onStart().
    Origin.sink(Origin.source());
    ExploitabilityRule.testMultihopExported(this);

    // The taint flow issue is only found on the lifecycle wrapper.
    // We need to mark the lifecycle wrapper as Exported to
    // find the exploitability issue.
    Origin.sink(mSource);
  }

  @Override
  protected void onCreate(Bundle bundle) {
    // Note: This method is modelled with 2 effect sources: Exported and
    // ExportedDfa.
    ExploitabilityRule.testMultipleEffectSourcesSameDistance(this);
  }

  protected void onDfaExported() {
    // Note: This method is modelled with effect source ExportedDfa only,
    // but is called from onCreate() which is an Exported
    ExploitabilityRule.testMultipleEffectSourcesDifferentDistance(this);
  }

  protected Intent getIntentHop1() {
    return getIntentHop2();
  }

  protected Intent getIntentHop2() {
    return this.getIntent();
  }

  protected Object getNewSourceHop1() {
    return getNewSourceHop2();
  }

  protected Object getNewSourceHop2() {
    return getNewSource();
  }

  protected Object getNewSource() {
    return new Object();
  }

  protected Object getTransformT1NewSource() {
    return ExploitabilityRule.transformT1(getNewSource());
  }

  protected void hopToIssue() {
    ExploitabilityRule.testExported(this);
  }

  protected void testMultiplePathsToExploitabilityRoot() {
    // This method is Exported _and_ has call-chain flows to the same exploitability-root via
    // multiple paths.
    // Expect: a single issue here.

    // Path 1: Direct path to issue.
    ExploitabilityRule.testExported(this);

    // Path 2: Hop to issue.
    hopToIssue();
  }

  protected void testExportedParameterSource() {
    ExploitabilityRule.testExportedParameterSource(/* untainted */ new Intent());

    // Expect issue: Source/Sink flow here with Source.
    ExploitabilityRule.testExportedParameterSource(/* tainted */ getIntent());
  }

  protected void testTransformOnSourceExported() {
    ExploitabilityRule.testTransformOnSourceExportedSimple(this);

    ExploitabilityRule.testTransformOnSourceExportedMultihop1(this);

    ExploitabilityRule.testTransformOnSourceExportedMultihop2(this);
  }

  protected void testTransformOnSinkExported() {
    ExploitabilityRule.testTransformOnSinkExportedSimple(this);

    ExploitabilityRule.testTransformOnSinkExportedMultihop(this);
  }
}

class UnexportedActivity extends Activity {
  private Object mSource;

  @Override
  protected void onCreate() {
    mSource = Origin.source();
    ExploitabilityRule.testUnexported(this);
  }

  @Override
  protected void onStart() {
    Origin.sink(mSource);
  }

  protected Object getNewSource() {
    return new Object();
  }

  protected void testTransformOnSourceUnexported() {
    ExploitabilityRule.testTransformOnSourceUnexported(this);
  }

  protected void testTransformOnSinkUnexported() {
    ExploitabilityRule.testTransformOnSinkUnexported(this);
  }
}

public class ExploitabilityRule {
  static void dfaSink(Object data) {}

  static void newSink(Object data) {}

  static void hopToSink(Object data) {
    Origin.sink(data);
  }

  static void hopToNewSink(Object data) {
    newSink(data);
  }

  static Object transformT1(Object o) {
    // Declared frozen propagation: Argument(0) -> `T1@LocalReturn`
    // Expect no inferred propagation: Argument(0) -> `LocalReturn`
    return o;
  }

  static Object hopToTransformT1(Object data) {
    return transformT1(data);
  }

  static void transformT1ToNewSink(Object data) {
    newSink(transformT1(data));
  }

  static void testExported(Activity activity) {
    // Expect issue: Source/Sink flow here + testExported() is "exported" via
    // ExportedActivity::onCreate()
    Origin.sink(activity.getIntent());
  }

  static void testUnexported(Activity activity) {
    // Expect no issue: Source/Sink flow here. But testUnexported()
    // called from UnexportedActivitiy::onCreate() is not "exported"
    Origin.sink(activity.getIntent());
  }

  static void testMultihopExported(ExportedActivity activity) {
    // Expect issue: Source/Sink flow here + testExported() is "exported" via
    // ExportedActivity::onCreate()
    hopToSink(activity.getIntentHop1());
  }

  static void testMultipleEffectSourcesSameDistance(Activity activity) {
    // Expect issue: Source/Sink flow here + testMultipleEffectSourcesSameDistance() is "exported"
    // via ExportedActivity::onCreate(Bundle) which has both Exported and
    // ExportedDfa. Expect both as sources.
    dfaSink(activity.getIntent());
  }

  static void testMultipleEffectSourcesDifferentDistance(Activity activity) {
    // Expect issue: Source/Sink flow here + testMultipleEffectSourcesDifferentDistance() is
    // ExportedDfa via ExportedActivity::onDfaExported(Bundle) but also is reachable from onCreate()
    // which is Exported. But expect issue for only the shortest distance, which is ExportedDfa.
    dfaSink(activity.getIntent());
  }

  static void testExportedParameterSource(Intent intent) {
    // Expect issue: Source/Sink flow here with ParameterSource.
    // Exported via ExportedActivity::testExportedParameterSource().
    hopToSink(intent);
  }

  static void testTransformOnSourceExportedSimple(ExportedActivity activity) {
    // Expect issue: NewSource -> T1 -> NewSink + testTransformOnSourceExported() is "exported" via
    // ExportedActivity::testTransformOnSourceExported().
    Object source = activity.getNewSource();
    Object sourceT1 = transformT1(source);
    newSink(sourceT1);
  }

  static void testTransformOnSourceExportedMultihop1(ExportedActivity activity) {
    // Expect issue: NewSource -> T1 -> NewSink + testTransformOnSourceExported() is "exported" via
    // ExportedActivity::testTransformOnSourceExported().
    Object source = activity.getNewSourceHop1();
    Object sourceT1 = hopToTransformT1(source);
    hopToNewSink(sourceT1);
  }

  static void testTransformOnSourceExportedMultihop2(ExportedActivity activity) {
    // Expect issue: NewSource -> T1 -> NewSink + testTransformOnSourceExported() is "exported" via
    // ExportedActivity::testTransformOnSourceExported().
    hopToNewSink(activity.getTransformT1NewSource());
  }

  static void testTransformOnSourceUnexported(UnexportedActivity activity) {
    // Expect no issue: NewSource -> T1 -> NewSink exists but
    // UnexportedActivity::testTransformOnSourceUnexported() is not exported.
    Object source = activity.getNewSource();
    Object sourceT1 = transformT1(source);
    newSink(sourceT1);
  }

  static void testTransformOnSinkExportedSimple(ExportedActivity activity) {
    // Expect issue: NewSource -> T1 -> NewSink + testTransformOnSinkExported() is "exported" via
    // ExportedActivity::testTransformOnSinkExported().
    transformT1ToNewSink(activity.getNewSource());
  }

  static void testTransformOnSinkExportedMultihop(ExportedActivity activity) {
    // Expect issue: NewSource -> T1 -> NewSink + testTransformOnSinkExported() is "exported" via
    // ExportedActivity::testTransformOnSinkExported().
    transformT1ToNewSink(activity.getNewSourceHop1());
  }

  static void testTransformOnSinkUnexported(UnexportedActivity activity) {
    // Expect no issue: NewSource -> T1 -> NewSink but
    // UnexportedActivity::testTransformOnSinkUnexported() is not exported.
    transformT1ToNewSink(activity.getNewSource());
  }
}

[{"title":"Welcome","type":0,"sectionRef":"#","url":"/blog/welcome/","content":"First post","keywords":"","version":null},{"title":"Build from Source","type":0,"sectionRef":"#","url":"/docs/build-from-source/","content":"","keywords":"","version":"Next"},{"title":"Supported Platforms​","type":1,"pageTitle":"Build from Source","url":"/docs/build-from-source/#supported-platforms","content":" Mariana Trench is currently supported on macOS (tested on Big Sur 11.4), Linux (tested on Ubuntu 20.04 LTS), and Android (via Termux).  ","version":"Next","tagName":"h2"},{"title":"Dependencies​","type":1,"pageTitle":"Build from Source","url":"/docs/build-from-source/#dependencies","content":" Below is a list of the required dependencies. Most of them can be installed with Homebrew.  A C++ compiler that supports C++20Python &gt;= 3.6CMake &gt;= 3.19.3zlibBoost &gt;= 1.75.0GoogleTest &gt;= 1.10.0JsonCpp &gt;= 1.9.4fmt &gt;= 7.1.2, &lt;= 9.1.0RE2Java (Optional)Android SDK (Optional)Redex (master)  ","version":"Next","tagName":"h2"},{"title":"Building and Installing​","type":1,"pageTitle":"Build from Source","url":"/docs/build-from-source/#building-and-installing","content":" ","version":"Next","tagName":"h2"},{"title":"Install all dependencies with Homebrew​","type":1,"pageTitle":"Build from Source","url":"/docs/build-from-source/#install-all-dependencies-with-homebrew","content":" First, follow the instructions to install Homebrew on your system.  Then, make sure homebrew is up-to-date:  $ brew update $ brew upgrade   Finally, install all the dependencies.  On macOS, run:  $ brew install python3 git cmake zlib boost googletest jsoncpp re2   On Linux, run:  $ brew install git cmake zlib boost jsoncpp re2 $ brew install googletest --build-from-source # The package is currently broken. $ export CMAKE_PREFIX_PATH=/home/linuxbrew/.linuxbrew/opt/jsoncpp:/home/linuxbrew/.linuxbrew/opt/zlib   On Linux, you will need to install Java to run the tests. For instance, on Ubuntu, run:  $ sudo apt install default-jre default-jdk   On Android (Termux):  $ pkg install -y git zlib boost googletest jsoncpp openjdk-17 jsoncpp-static boost-headers binutils build-essential rsync   On Termux, you will also need to build RE2 and Google Benchmark from source:  # Build RE2 $ cd &quot;$HOME&quot; $ git clone https://github.com/google/re2.git --depth 1 $ cd re2/ $ cmake -DCMAKE_INSTALL_PREFIX=&quot;$MARIANA_TRENCH_DIRECTORY/install&quot; -S . -B build $ cd build $ make $ make install # Build benchmark $ cd &quot;$HOME&quot; $ git clone https://github.com/google/benchmark.git --depth 1 $ cd benchmark $ cmake -DBENCHMARK_DOWNLOAD_DEPENDENCIES=on -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=&quot;$MARIANA_TRENCH_DIRECTORY/install&quot; -DBENCHMARK_ENABLE_GTEST_TESTS=OFF -S . -B &quot;build&quot; $ cmake --build &quot;build&quot; --config Release --target install   And, you also need to clone libbinder (required for building Redex):  $ git clone https://github.com/D-os/libbinder.git --depth 1 &quot;$TMPDIR/libbinder&quot;   ","version":"Next","tagName":"h3"},{"title":"Clone the repository​","type":1,"pageTitle":"Build from Source","url":"/docs/build-from-source/#clone-the-repository","content":" First of, clone the Mariana Trench repository. We will also set an environment variable MARIANA_TRENCH_DIRECTORY that points to it for the following instructions.  $ git clone https://github.com/facebook/mariana-trench.git $ cd mariana-trench $ MARIANA_TRENCH_DIRECTORY=&quot;$PWD&quot;   ","version":"Next","tagName":"h3"},{"title":"Installation directory​","type":1,"pageTitle":"Build from Source","url":"/docs/build-from-source/#installation-directory","content":" We do not recommend installing Mariana Trench as root. Instead, we will install all libraries and binaries in a directory &quot;install&quot;. We will also use a directory called &quot;dependencies&quot; to store dependencies that we have to build from source. Run the following commands:  $ mkdir install $ mkdir dependencies   ","version":"Next","tagName":"h3"},{"title":"Building fmt​","type":1,"pageTitle":"Build from Source","url":"/docs/build-from-source/#building-fmt","content":" The 9.0 release of fmt has breaking changes that Mariana Trench is not yet compatible with, so for now, you need to build the library from source. You will need to do the following:  $ cd &quot;$MARIANA_TRENCH_DIRECTORY/dependencies&quot; $ git clone -b 9.1.0 https://github.com/fmtlib/fmt.git $ mkdir fmt/build $ cd fmt/build $ cmake -DCMAKE_CXX_STANDARD=17 -DFMT_TEST=OFF -DCMAKE_INSTALL_PREFIX=&quot;$MARIANA_TRENCH_DIRECTORY/install&quot; .. $ make -j4 $ make install   ","version":"Next","tagName":"h3"},{"title":"Building Redex​","type":1,"pageTitle":"Build from Source","url":"/docs/build-from-source/#building-redex","content":" We also need to build Redex from source.  First, navigate to the dependencies directory and clone Redex:  $ cd &quot;$MARIANA_TRENCH_DIRECTORY/dependencies&quot; $ git clone https://github.com/facebook/redex.git $ mkdir redex/build $ cd redex/build   Then, run cmake with platform-specific flags:  On macOS/Linux:  $ cmake -DCMAKE_INSTALL_PREFIX=&quot;$MARIANA_TRENCH_DIRECTORY/install&quot; ..   On Termux:  $ cmake -DCMAKE_INSTALL_PREFIX=&quot;$MARIANA_TRENCH_DIRECTORY/install&quot; -DCMAKE_CXX_FLAGS=&quot;-I$TMPDIR/libbinder/include&quot; ..   Finally, build and install Redex:  $ make -j4 $ make install   ","version":"Next","tagName":"h3"},{"title":"Building Mariana Trench​","type":1,"pageTitle":"Build from Source","url":"/docs/build-from-source/#building-mariana-trench","content":" Now that we have our dependencies ready, let's build the Mariana Trench binary:  $ cd &quot;$MARIANA_TRENCH_DIRECTORY&quot; $ mkdir build $ cd build $ cmake \\ -DREDEX_ROOT=&quot;$MARIANA_TRENCH_DIRECTORY/install&quot; \\ -Dfmt_ROOT=&quot;$MARIANA_TRENCH_DIRECTORY/install&quot; \\ -DCMAKE_INSTALL_PREFIX=&quot;$MARIANA_TRENCH_DIRECTORY/install&quot; \\ .. $ make -j4 $ make install   Finally, let's install Mariana Trench as a Python package. First, follow the instructions to create a virtual environment. Once inside a virtual environment (after using the activate script), run:  $ cd &quot;$MARIANA_TRENCH_DIRECTORY&quot; $ python scripts/setup.py \\ --binary &quot;$MARIANA_TRENCH_DIRECTORY/install/bin/mariana-trench-binary&quot; \\ --pyredex &quot;$MARIANA_TRENCH_DIRECTORY/install/bin/pyredex&quot; \\ install   ","version":"Next","tagName":"h3"},{"title":"Testing during development​","type":1,"pageTitle":"Build from Source","url":"/docs/build-from-source/#testing-during-development","content":" If you are making changes to Mariana Trench, you can use the mariana-trench wrapper inside the build directory:  $ cd build $ ./mariana-trench --help   This way, you don't have to call scripts/setup.py between every changes. Python changes will be automatically picked up. C++ changes will be picked up after running make.  Note that you will need to install all python dependencies:  $ pip install pyre_extensions fb-sapp   ","version":"Next","tagName":"h2"},{"title":"Running the tests​","type":1,"pageTitle":"Build from Source","url":"/docs/build-from-source/#running-the-tests","content":" To run the tests after building Mariana Trench, use:  $ cd build $ make check   ","version":"Next","tagName":"h2"},{"title":"Troubleshooting​","type":1,"pageTitle":"Build from Source","url":"/docs/build-from-source/#troubleshooting","content":" Here are a set of errors you might encounter, and their solutions.  ","version":"Next","tagName":"h2"},{"title":"CMake Warning: Ignoring extra path from command line: \"..\"​","type":1,"pageTitle":"Build from Source","url":"/docs/build-from-source/#cmake-warning-ignoring-extra-path-from-command-line-","content":" You probably tried to run cmake from the wrong directory. Make sure that $MARIANA_TRENCH_DIRECTORY is set correctly (test with echo $MARIANA_TRENCH_DIRECTORY). Then, run the instructions again from the beginning of the section you are in.  ","version":"Next","tagName":"h3"},{"title":"error: externally-managed-environment​","type":1,"pageTitle":"Build from Source","url":"/docs/build-from-source/#error-externally-managed-environment","content":" You probably tried to run python scripts/setup.py without a virtual environment. Create a virtual environment first.  ","version":"Next","tagName":"h3"},{"title":"undefined reference to pthread_create@GLIBC​","type":1,"pageTitle":"Build from Source","url":"/docs/build-from-source/#undefined-reference-to-pthread_createglibc","content":" This seems to happen on Linux, when your operating system has an old version of glibc, which doesn't match the version used by Homebrew. Try upgrading your operating system to the last version.  Another option is to use the compiler (gcc) from Homebrew directly:  $ brew install gcc export CC=/home/linuxbrew/.linuxbrew/bin/cc export CXX=/home/linuxbrew/.linuxbrew/bin/c++   You will need to run all the instructions from this page again, starting from Clone the repository. We recommend starting from scratch, i.e delete the mariana-trench directory.  ","version":"Next","tagName":"h3"},{"title":"error: ZLIB::ZLIB target not found​","type":1,"pageTitle":"Build from Source","url":"/docs/build-from-source/#error-zlibzlib-target-not-found","content":" The following error indicates that cmake failed to find zlib:  CMake Error at CMakeLists.txt:131 (target_link_libraries): Target &quot;redex-all&quot; links to: ZLIB::ZLIB but the target was not found.   This can be fixed by providing the path to zlib when running cmake:  cmake [options] -DZLIB_HOME=/path/to/zlib ..   (Note how the cmake command must end with .. to refer to the parent directory)  If zlib was installed with Homebrew (common on macOS), use:  cmake [options] -DZLIB_HOME=&quot;$(brew --prefix)/opt/zlib&quot; ..  ","version":"Next","tagName":"h3"},{"title":"Analysis Configuration Options","type":0,"sectionRef":"#","url":"/docs/configuration/","content":"","keywords":"","version":"Next"},{"title":"Command Line Options​","type":1,"pageTitle":"Analysis Configuration Options","url":"/docs/configuration/#command-line-options","content":" You can get a full set of options by running mariana-trench --help. The following is an abbreviated version of the output.  $ mariana-trench --help Target arguments: --apk-path APK_PATH The APK to analyze. Output arguments: --output-directory OUTPUT_DIRECTORY The directory to store results in. Configuration arguments: --system-jar-configuration-path SYSTEM_JAR_CONFIGURATION_PATH A JSON configuration file with a list of paths to the system jars. --rules-paths RULES_PATHS A `;`-separated list of rules files and directories containing rules files. --repository-root-directory REPOSITORY_ROOT_DIRECTORY The root of the repository. Resulting paths will be relative to this. --source-root-directory SOURCE_ROOT_DIRECTORY The root where source files for the APK can be found. --model-generator-configuration-paths MODEL_GENERATOR_CONFIGURATION_PATHS A `;`-separated list of paths specifying JSON configuration files. Each file is a list of paths to JSON model generators relative to the configuration file or names of CPP model generators. --model-generator-search-paths MODEL_GENERATOR_SEARCH_PATHS A `;`-separated list of paths where we look up JSON model generators. --maximum-source-sink-distance MAXIMUM_SOURCE_SINK_DISTANCE Limits the distance of sources and sinks from a trace entry point.   --apk-path​  Mariana Trench analyzes Dalvik bytecode. You provide it with the android app (APK) to analyze.  --output-directory OUTPUT_DIRECTORY​  The output of the analysis is a file containing metadata about the particular run in JSON format as well as sharded files containing data flow specifications for every method in the APK. These files need to be processed by SAPP (see Getting Started) after the analysis. The flag specifies where these files are saved.  --system-jar-configuration-path SYSTEM_JAR_CONFIGURATION_PATH​  This path points to a json file containing a list of .jar files that the analysis should include in the analysis. It's important that this contains at least the path to android.jar on your system. This file is typically located in your android SDK distribution at $ANDROID_SDK/platforms/android-30/android.jar. Without the android.jar, Mariana Trench will not know about many methods from the standard library that might be important for your model generators.  --rules-paths RULES_PATHS​  A ; separated search path pointing to files and directories containing rules files. These files specify what taint flows Mariana Trench should look for. Check out the rules.json that's provided by default. It specifies that we want to find flows from user controlled input (ActivityUserInput) into CodeExecution sinks and that this constitutes a remote code execution.  --source-root-directory SOURCE_ROOT_DIRECTORY​  Mariana Trench will do a source indexing path before the analysis. This is because Dalvik/Java bytecode does not contain complete location information, only filenames (not paths) and line numbers. The index is later used to emit precise locations.  --model-generator-configuration-paths MODEL_GENERATOR_CONFIGURATION_PATHS​  A ; separated set of files containing the names of model generators to run. See default_generator_config.json for an example.  --model-generator-search-paths MODEL_GENERATOR_SEARCH_PATHS​  A ; separated search path where Mariana Trench will try to find the model generators specified in the generator configuration.  --maximum-source-sink-distance MAXIMUM_SOURCE_SINK_DISTANCE​  For performance reasons it can be useful to limit the maximum length of a trace Mariana Trench tries to find (note that longer traces also tend to be harder to interpret). Due to the modular nature of the analysis the value specified here limits the maximum length from the trace root to the source, and from the trace root to the sink. This means found traces can have length of 2 x MAXIMUM_SOURCE_SINK_DISTANCE.  --heuristics HEURISTICS_FILE_PATH​  Mariana Trench uses various heuristics parameters during the analysis. It is possible to set some of them with a JSON configuration file. The complete list of configurable parameters is reported in the heuristics parameters section. It is optional to specify a configuration for the heuristics parameters, and the the parameters that are not specified are set to a default value.  ","version":"Next","tagName":"h2"},{"title":"Heuristics Parameters​","type":1,"pageTitle":"Analysis Configuration Options","url":"/docs/configuration/#heuristics-parameters","content":" join_override_threshold INT​  When a method has a set of overrides greater than this threshold, Mariana Trench does not join all overrides at call sites.  android_join_override_threshold INT​  When an android/java/google method has a set of overrides which is greater than this threshold, Mariana Trench does not join all overrides at call sites.  warn_override_threshold INT​  When a method which has a set of overrides greater than this threshold that is not marked with NoJoinVirtualOverrides is called at least once, Mariana Trench prints a warning.  generation_max_port_size INT​  Maximum size of the port of a generation.  generation_max_output_path_leaves INT​  Maximum number of leaves in the tree of output paths of generations. When reaching the maximum, Mariana Trench collapses all the subtrees into a single node.  parameter_source_max_port_size INT​  Maximum size of the port of a parameter source.  parameter_source_max_output_path_leaves INT​  Maximum number of leaves in the tree of output paths of parameter sources. When reaching the maximum, Mariana Trench collapses all the subtrees into a single node.  sink_max_port_size INT​  Maximum size of the port of a sink.  sink_max_input_path_leaves INT​  Maximum number of leaves in the tree of input paths of sinks. When reaching the maximum, Mariana Trench collapses all the subtrees into a single node.  call_effect_source_max_port_size INT​  Maximum size of the port of a call effect source.  call_effect_source_max_output_path_leaves INT​  Maximum number of leaves in the tree of output paths of call effect sources. When reaching the maximum, Mariana Trench collapses all the subtrees into a single node.  call_effect_sink_max_port_size INT​  Maximum size of the port of a call effect sink.  call_effect_sink_max_input_path_leaves INT​  Maximum number of leaves in the tree of input paths of call effect sinks. When reaching the maximum, Mariana Trench collapses all the subtrees into a single node.  max_number_iterations INT​  Maximum number of global iterations before Mariana Trench aborts the analysis.  max_depth_class_properties INT​  Maximum depth of dependency graph traversal to find class properties.  max_call_chain_source_sink_distance INT​  Maximum number of hops that can be tracked for a call chain issue.  propagation_max_input_path_size INT​  Maximum size of the input access path of a propagation.  propagation_max_input_path_leaves INT​  Maximum number of leaves in the tree of input paths of propagations.  ","version":"Next","tagName":"h2"},{"title":"Heuristics Parameter Configuration Example​","type":1,"pageTitle":"Analysis Configuration Options","url":"/docs/configuration/#heuristics-parameter-configuration-example","content":" The following JSON document is a valid configuration file for the heuristics parameters. Typically, we try to find a balance between precision of the analysis and performance.  { &quot;join_override_threshold&quot;: 100, &quot;android_join_override_threshold&quot;: 100, &quot;warn_override_threshold&quot;: 100, &quot;generation_max_port_size&quot;: 10, &quot;generation_max_output_path_leaves&quot;: 30, &quot;parameter_source_max_port_size&quot;: 10, &quot;parameter_source_max_output_path_leaves&quot;: 30, &quot;sink_max_port_size&quot;: 10, &quot;sink_max_input_path_leaves&quot;: 30, &quot;call_effect_source_max_port_size&quot;: 10, &quot;call_effect_source_max_output_path_leaves&quot;: 30, &quot;call_effect_sink_max_port_size&quot;: 10, &quot;call_effect_sink_max_input_path_leaves&quot;: 30, &quot;max_number_iterations&quot;: 300, &quot;max_depth_class_properties&quot;: 30, &quot;max_call_chain_source_sink_distance&quot;: 30, &quot;propagation_max_input_path_size&quot;: 10, &quot;propagation_max_input_path_leaves&quot;: 10 }  ","version":"Next","tagName":"h3"},{"title":"Customize Sources and Sinks","type":0,"sectionRef":"#","url":"/docs/customize-sources-and-sinks/","content":"","keywords":"","version":"Next"},{"title":"Overview​","type":1,"pageTitle":"Customize Sources and Sinks","url":"/docs/customize-sources-and-sinks/#overview","content":" Under the context of Mariana Trench, we talk about sources and sinks in terms of methods (or, rarely, fields). For example, we may say that the return value of a method is a source (or a sink). We may also say that the 2nd parameter of a method is a source (or a sink). Such description of a method is called a &quot;model&quot;. See Models &amp; Model Generators for more details about models and writing them.    To define sources or sinks that are not contained in the default set of sources and sinks, a user needs to: Write one or more JSON files that respect our model generator Domain Specific Language (DSL), which express how to generate models from methods and are hence called &quot;model generators&quot;. For example, a model generator may say that, for all methods (that will be analyzed by Mariana Trench) whose name is onActivityResult, specify their 2nd parameter as a source. { &quot;model_generators&quot;: [ { &quot;find&quot;: &quot;methods&quot;, &quot;where&quot;: [ { &quot;constraint&quot;: &quot;name&quot;, &quot;pattern&quot;: &quot;onActivityResult&quot; } ], &quot;model&quot;: { &quot;sources&quot;: [ { &quot;kind&quot;: &quot;TestSensitiveUserInput&quot;, &quot;port&quot;: &quot;Argument(2)&quot; } ] } } ] } Instruct Mariana Trench to read from your model generator, so that Mariana Trench will generate models at runtime. Intuitively, the models generated (by interpreting model generators) express sources and sinks for each method before running Mariana Trench. Based on such models, Mariana Trench will automatically infer new models for each method at runtime.To instruct Mariana Trench to read from customized JSON model generators, add your json model generator here.Add the model generator name (i.e, the file name) in the JSON configuration file. Update &quot;rules&quot; if necessary. Background: Mariana Trench categorizes sources and sinks into different &quot;kinds&quot;, which are string-typed. For example, a source may have a kind ofJavascriptInterfaceUserInput. A sink may have a kind of Logging. Mariana Trench only finds data flow from sources of a particular kind to sinks of another particular kind, which are called &quot;rules&quot;. See Rules for writing them.To specify kinds that are not mentioned in the default set of rules or to specify rules that are different than the default rules, you need to specify a new rule in file rules.json, in order to instruct Mariana Trench to find data flow that matches the new rule.For example, to catch flows from TestSensitiveUserInput in the example above and the sink kind Logging, you can add the following rule to the default rules.json: { &quot;name&quot;: &quot;TestRule&quot;, &quot;code&quot;: 18, &quot;description&quot;: &quot;A test rule&quot;, &quot;sources&quot;: [ &quot;TestSensitiveUserInput&quot; ], &quot;sinks&quot;: [ &quot;Logging&quot; ] }  ","version":"Next","tagName":"h2"},{"title":"Debugging False Positives/False Negatives","type":0,"sectionRef":"#","url":"/docs/debugging-fp-fns/","content":"","keywords":"","version":"Next"},{"title":"Setup​","type":1,"pageTitle":"Debugging False Positives/False Negatives","url":"/docs/debugging-fp-fns/#setup","content":"First, you need to run the analysis on your computer. This will create model@XXX.json files in the current directory, containing the results of the analysis.    ","version":"Next","tagName":"h2"},{"title":"Investigate the output models​","type":1,"pageTitle":"Debugging False Positives/False Negatives","url":"/docs/debugging-fp-fns/#investigate-the-output-models","content":" Now, your objective is to understand in which method we lost the flow (false negative) or introduced the invalid flow (false positive). You will need to look into the output models for that. These models include both the declared models and inferred models. Declared models are models explicitly written out or created by a model generator. Inferred models are models created by Mariana Trench's analysis of other models and the code. I recommend using the explore_models.py bento script.  Run the following command in the directory containing the output model files (i.e, model@XXX.json):  python3 -i mariana_trench_repository/scripts/explore_models.py     This provides you with a few helper functions:   index('.') Index all available models in the given directory. method_containing('Foo;.bar') Find all methods containing the given string. method_matching('Foo.*') Find all methods matching the given regular expression. get_model('Foo;.bar') Get the model for the given method. print_model('Foo;.bar') Pretty print the model for the given method.   Use index to index all models first:  In [1]: index()   Now you can search for methods with method_containing and print their models with print_model. You probably want to look at the first or last frame of the trace, to see if the source or sink is present. Then, you will want to follow the frames until you find the problematic method.  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Debugging False Positives/False Negatives","url":"/docs/debugging-fp-fns/#example","content":" Let's suppose I am investigating a false negative, I want to find in which method we are losing the flow. I could start looking at the last frame, i.e the sink:  In [2]: method_containing('Landroid/content/Context;.sendOrderedBroadcast') Out[2]: ['Landroid/content/Context;.sendOrderedBroadcast:(Landroid/content/Intent;Ljava/lang/String;)V', 'Landroid/content/Context;.sendOrderedBroadcast:(Landroid/content/Intent;Ljava/lang/String;Landroid/content/BroadcastReceiver;Landroid/os/Handler;ILjava/lang/String;Landroid/os/Bundle;)V', 'Landroid/content/Context;.sendOrderedBroadcastAsUser:(Landroid/content/Intent;Landroid/os/UserHandle;Ljava/lang/String;Landroid/content/BroadcastReceiver;Landroid/os/Handler;ILjava/lang/String;Landroid/os/Bundle;)V'] In [3]: print_model('Landroid/content/Context;.sendOrderedBroadcast:(Landroid/content/Intent;Ljava/lang/String;Landroid/content/BroadcastReceiver;Landroid/os/Handler;ILjava/lang/String;Landroid/os/Bundle;)V') { &quot;method&quot;: &quot;Landroid/content/Context;.sendOrderedBroadcast:(Landroid/content/Intent;Ljava/lang/String;Landroid/content/BroadcastReceiver;Landroid/os/Handler;ILjava/lang/String;Landroid/os/Bundle;)V&quot;, &quot;modes&quot;: [ &quot;skip-analysis&quot;, &quot;add-via-obscure-feature&quot;, &quot;taint-in-taint-out&quot;, &quot;taint-in-taint-this&quot;, &quot;no-join-virtual-overrides&quot; ], &quot;position&quot;: { &quot;path&quot;: &quot;android/content/Context.java&quot; }, ... &quot;sinks&quot;: [ { &quot;callee_port&quot;: &quot;Leaf&quot;, &quot;caller_port&quot;: &quot;Argument(1)&quot;, &quot;kind&quot;: &quot;LaunchingComponent&quot;, &quot;origins&quot;: [ &quot;Landroid/content/Context;.sendOrderedBroadcast:(Landroid/content/Intent;Ljava/lang/String;Landroid/content/BroadcastReceiver;Landroid/os/Handler;ILjava/lang/String;Landroid/os/Bundle;)V&quot; ] } ] }   As expected, the method has a sink on Argument(1), so we are good for now. Next, I want to check the previous frame, which calls Context.sendOrderedBroadcast:  In [2]: method_containing('ShortcutManagerCompat;.requestPinShortcut:') Out[2]: ['Landroidx/core/content/pm/ShortcutManagerCompat;.requestPinShortcut:(Landroid/content/Context;Landroidx/core/content/pm/ShortcutInfoCompat;Landroid/content/IntentSender;)Z'] In [3]: print_model('Landroidx/core/content/pm/ShortcutManagerCompat;.requestPinShortcut:(Landroid/content/Context;Landroidx/core/content/pm/ShortcutInfoCompat;Landroid/content/IntentSender;)Z') { &quot;method&quot;: &quot;Landroidx/core/content/pm/ShortcutManagerCompat;.requestPinShortcut:(Landroid/content/Context;Landroidx/core/content/pm/ShortcutInfoCompat;Landroid/content/IntentSender;)Z&quot;, &quot;position&quot;: { &quot;line&quot;: 112, &quot;path&quot;: &quot;androidx/core/content/pm/ShortcutManagerCompat.java&quot; }, ... &quot;sinks&quot;: [ ... { &quot;always_features&quot;: [ &quot;via-obscure&quot;, &quot;via-obscure-taint-in-taint-this&quot;, &quot;via-intent-extra&quot;, &quot;has-intent-extras&quot; ], &quot;call_position&quot;: { &quot;line&quot;: 130, &quot;path&quot;: &quot;androidx/core/content/pm/ShortcutManagerCompat.java&quot; }, &quot;callee&quot;: &quot;Landroid/content/Context;.sendOrderedBroadcast:(Landroid/content/Intent;Ljava/lang/String;Landroid/content/BroadcastReceiver;Landroid/os/Handler;ILjava/lang/String;Landroid/os/Bundle;)V&quot;, &quot;callee_port&quot;: &quot;Argument(1)&quot;, &quot;caller_port&quot;: &quot;Argument(1).mIntents&quot;, &quot;distance&quot;: 1, &quot;kind&quot;: &quot;LaunchingComponent&quot;, &quot;local_positions&quot;: [ { &quot;line&quot;: 121 } ], &quot;origins&quot;: [ &quot;Landroid/content/Context;.sendOrderedBroadcast:(Landroid/content/Intent;Ljava/lang/String;Landroid/content/BroadcastReceiver;Landroid/os/Handler;ILjava/lang/String;Landroid/os/Bundle;)V&quot; ] } ] }   I can see the frame from ShortcutManagerCompat.requestPinShortcut on Argument(1).mIntents to Context.sendOrderedBroadcast on Argument(1). I can keep following frames until I find the method that misses a source or sink.  For frames from the source to the root callable, I should look at generations, and for frames from the root callable to the sink, I should look at sinks. On the root callable, I should look at issues.  As you can see above, methods can have very long signatures. Fortunately, the bento script is also a python REPL, so you can assign them to variables  In [4]:requestPinShortcut = 'Landroidx/core/content/pm/ShortcutManagerCompat;.requestPinShortcut:(Landroid/content/Context;Landroidx/core/content/pm/ShortcutInfoCompat;Landroid/content/IntentSender;)Z' In [5]:pm = print_model In [6]:pm(requestPinShortcut) { &quot;method&quot;: &quot;Landroidx/core/content/pm/ShortcutManagerCompat;.requestPinShortcut:(Landroid/content/Context;Landroidx/core/content/pm/ShortcutInfoCompat;Landroid/content/IntentSender;)Z&quot;, &quot;position&quot;: { &quot;line&quot;: 112, &quot;path&quot;: &quot;androidx/core/content/pm/ShortcutManagerCompat.java&quot; }, ... }   ","version":"Next","tagName":"h3"},{"title":"Investigating the transfer function​","type":1,"pageTitle":"Debugging False Positives/False Negatives","url":"/docs/debugging-fp-fns/#investigating-the-transfer-function","content":" Once you know in which method you are losing the flow or introducing an invalid flow, you will need to run the analysis with logging enabled for that method, using:  mariana-trench \\ --apk-path='your-apk' \\ --log-method='method-name'     This will log everything the transfer function does in that method, which might be a lot of logs. You can pipe this into a file or into less. Using logs, you should be able to see in which instruction you are losing the taint. Remember, the analysis computes a fixpoint, so the method will be analyzed multiple times. You should look at the last time it was analyzed (i.e, end of the logs).  Happy debugging! ","version":"Next","tagName":"h2"},{"title":"Exploitability Rules","type":0,"sectionRef":"#","url":"/docs/exploitability-rules/","content":"","keywords":"","version":"Next"},{"title":"Exploitability Rules​","type":1,"pageTitle":"Exploitability Rules","url":"/docs/exploitability-rules/#exploitability-rules","content":" For android, some source to sink flows are only considered valid if the root callable of the source to sink flow is also accessible from outside the app. This access is controlled by exported setting in the manifest file. Exploitability rules allow us to additionally constraint source to sink rules on a call-chain flow from the root callable of the source to sink flow up to a call-chain effect source which is identified using the android manifest. Eg.  class ExportedActivity extends Activity { void onCreate() { Util.exploitabilityRootCallable(this); } } class Util { void exploitabilityRootCallable(Activity activity) { toSink(activity.getSource()); } }   Here, if we want to report an issue only if the android manifest sets exported: true for ExportedActivity. You can specify the explotability rule as follows:  { &quot;name&quot;: &quot;Source to sink flow is reachable from an exported class&quot;, &quot;code&quot;: 1, &quot;description&quot;: &quot;Values from source may eventually flow into sink&quot;, &quot;sources&quot;: [ &quot;ActivityUserInput&quot; ], &quot;effect_sources&quot;: [ &quot;Exported&quot; ], &quot;sinks&quot;: [ &quot;LaunchingComponent&quot; ] }   Here, source to sink flow is found in rootExploitabilityCallable() but the issue will be reported iff ExportedActivity has exported:true in the android manifest.   ExportedActivity::onCreate(): with effect_source: Exported | exploitabilityRootCallable(): with inferred effect_sink: | SourceAsTransform[ActivityUserInput]@LaunchingComponent +-----------------+-----------------+ | | getSource(): with toSink(): with source kind: ActivityUserInput sink kind: LaunchingComponent   ","version":"Next","tagName":"h3"},{"title":"android_lifecycles","type":0,"sectionRef":"#","url":"/docs/fb/android_lifecycles/","content":"android_lifecycles","keywords":"","version":"Next"},{"title":"Android/API Lifecycles","type":0,"sectionRef":"#","url":"/docs/android-lifecycles/","content":"","keywords":"","version":"Next"},{"title":"Background​","type":1,"pageTitle":"Android/API Lifecycles","url":"/docs/android-lifecycles/#background","content":" Framework classes often provide overridable methods that subclasses can override. These methods are frequently executed in some sequence. The most direct example of this would be the Activity lifecycle. Sub-classes implement methods like onCreate(), onStart(), onResume(), etc. which is internally chained up in the base class.  The analysis may see this chain if the code for the base class is available. However, because the base class can be overridden by many different children, the analysis cannot easily differentiate between flows Child1.onCreate() -&gt; Child1.onStart() and Child1.onCreate() -&gt; Child2.onStart(). The latter could result in a false positives. There could also be too many children and which causes the analysis to drop taint and fail to find any flow.  To get around this, we allow users to define lifecycles for these framework classes.  ","version":"Next","tagName":"h2"},{"title":"Lifecycle Configuration​","type":1,"pageTitle":"Android/API Lifecycles","url":"/docs/android-lifecycles/#lifecycle-configuration","content":"   The default lifecycles are defined in configuration/lifecycles.json.  ","version":"Next","tagName":"h2"},{"title":"Lifecycle Definition​","type":1,"pageTitle":"Android/API Lifecycles","url":"/docs/android-lifecycles/#lifecycle-definition","content":" Lifecycles are defined in a JSON file and passed into the analysis via the --lifecycles-paths option. The definition contains three basic components, a &quot;base_class_name&quot;, a &quot;method_name&quot;, and set of overridable methods (callees) with their name and prototypes. Mariana Trench internally creates artificial methods with signature &lt;child of base_class_name&gt;.&lt;method_name&gt;(args for callees) that invokes the callees.  A few notes on lifecycle definitions in general:  The &quot;method_name&quot; must be unique across all lifecycles. Children could extend multiple base classes. If their respective lifecycle definitions share a &quot;method_name&quot;, there will be a conflict.Only children at the leaves of the class hierarchy will have the artificial method created, so taint flow will only be detected in these classes.All callee methods are expected to be defined in the base class and is validated to detect invalid configurations. However, if a method only exists in some derived classes down the class hierarchy, the callee should contain a &quot;defined_in_derived_class&quot; field. This field specifies the derived class where the method is defined, indicating Mariana Trench that the method does not exist in the base class, but in some classes extending it. This allows the method to be included in the generated lifecycle method.  The way the method is constructed (e.g., the order callees are invoked) depends on the kind of lifecycle definitions. Mariana Trench currently supports two kinds of lifecycle definitions: linear lifecycles and lifecycle graphs.  ","version":"Next","tagName":"h2"},{"title":"Linear Lifecycles​","type":1,"pageTitle":"Android/API Lifecycles","url":"/docs/android-lifecycles/#linear-lifecycles","content":" In linear lifecycle definitions, the callees are defined in the &quot;callees&quot; array. The analysis generates the artificial method that invokes the callees in the order defined in the array (thus the name &quot;linear&quot;). Here is a sample definition:   { &quot;base_class_name&quot;: &quot;Landroidx/fragment/app/FragmentActivity;&quot;, &quot;method_name&quot;: &quot;activity_lifecycle_wrapper&quot;, &quot;callees&quot;: [ { &quot;method_name&quot;: &quot;onCreate&quot;, &quot;return_type&quot;: &quot;V&quot;, &quot;argument_types&quot;: [ &quot;Landroid/os/Bundle;&quot; ] }, { &quot;method_name&quot;: &quot;onStart&quot;, &quot;return_type&quot;: &quot;V&quot;, &quot;argument_types&quot;: [] }, { &quot;method_name&quot;: &quot;onTest&quot;, &quot;return_type&quot;: &quot;V&quot;, &quot;argument_types&quot;: [ &quot;Ljava/lang/Object;&quot; ], &quot;defined_in_derived_class&quot;: &quot;Lcom/facebook/marianatrench/integrationtests/FragmentOneActivity;&quot; } ] }   ","version":"Next","tagName":"h3"},{"title":"Lifecycle Graphs​","type":1,"pageTitle":"Android/API Lifecycles","url":"/docs/android-lifecycles/#lifecycle-graphs","content":" One issue with the linear lifecycle definition is that it does not model more complex lifecycle transitions in real-world settings. For example, when the user navigates away from the activity, spends some time in other activity, and then navigates back, the onStart method would be called again. This state transition loop cannot be captured by linear lifecycle definitions.  The lifecycle graph aims to solve this issue by allowing users to specify the transition relationships between the lifecycle states together with their corresponding methods as graphs. A sample lifecycle graph definition looks like this:   { &quot;base_class_name&quot;: &quot;Landroid/app/Activity;&quot;, &quot;method_name&quot;: &quot;activity_lifecycle_wrapper&quot;, &quot;control_flow_graph&quot;: { &quot;entry&quot;: { &quot;instructions&quot;: [ { &quot;method_name&quot;: &quot;&lt;init&gt;&quot;, &quot;return_type&quot;: &quot;V&quot;, &quot;argument_types&quot;: [] } ], &quot;successors&quot;: [ &quot;onCreate&quot; ] }, &quot;onCreate&quot;: { &quot;instructions&quot;: [ { &quot;method_name&quot;: &quot;onCreate&quot;, &quot;return_type&quot;: &quot;V&quot;, &quot;argument_types&quot;: [ &quot;Landroid/os/Bundle;&quot; ] } ], &quot;successors&quot;: [ &quot;exit&quot; ] }, &quot;exit&quot;: { &quot;instructions&quot;: [ { &quot;method_name&quot;: &quot;onStart&quot;, &quot;return_type&quot;: &quot;V&quot;, &quot;argument_types&quot;: [] } ], &quot;successors&quot;: [ &quot;onCreate&quot; ] } } }   Several important points to note for the definition:  By defining the &quot;control_flow_graph&quot; field instead of &quot;callees&quot; in linear lifecycles, Mariana Trench will automatically treat this definition as a lifecycle graph.Each object in the &quot;control_flow_graph&quot; is a graph node that represents the lifecycle state. For each node, the &quot;instructions&quot; array contains the callees that should be invoked in the current state. The &quot;successors&quot; array contains keys of the states that the current state could transit to (e.g. &quot;onCreate&quot; would transit to &quot;onStart&quot;).There are two special node names, &quot;entry&quot; and &quot;exit&quot;, which corresponds to the entry and exit nodes of the graph. The entry node is required. The exit node is optional, but any node that is not the exit node must have at least one successor.  Method Generation for Lifecycle Graphs​  Internally, Mariana Trench will create one basic block for each graph node. The basic block will contain invocations to the methods associated with the node, and end with a switch that connects it to each of its successors. As an example, the above configuration may generate the following code for a class MainActivity that extends android.app.Activity:  Block 0 (entry): IOPCODE_LOAD_PARAM_OBJECT v0 IOPCODE_LOAD_PARAM_OBJECT v1 Successors: {3} Block 1: INVOKE_VIRTUAL v0, v1, Lcom/facebook/marianatrench/integrationtests/MainActivity;.onCreate:(Landroid/os/Bundle;)V SWITCH v2 Successors: {2} Block 2: INVOKE_VIRTUAL v0, Lcom/facebook/marianatrench/integrationtests/MainActivity;.onStart:()V SWITCH v3 Successors: {4, 1} Block 3: INVOKE_VIRTUAL v0, Lcom/facebook/marianatrench/integrationtests/MainActivity;.&lt;init&gt;:()V SWITCH v4 Successors: {1} Block 4: RETURN_VOID   Here, the block 1, 2, and 3 maps to the &quot;onCreate&quot;, &quot;exit&quot;, and &quot;entry&quot; nodes, respectively. Block 0 is the real entry block of the method, which loads all parameters and jumps into the block associated with the &quot;entry&quot; node (i.e., block 3). Block 4 is the real exit node of the method, which contains the return instruction. The block associated with the &quot;exit&quot; node (i.e., block 2) will have a branch to this real exit block. ","version":"Next","tagName":"h3"},{"title":"customize_sources_and_sinks","type":0,"sectionRef":"#","url":"/docs/fb/customize_sources_and_sinks/","content":"customize_sources_and_sinks","keywords":"","version":"Next"},{"title":"debugging_fp_fns","type":0,"sectionRef":"#","url":"/docs/fb/debugging_fp_fns/","content":"debugging_fp_fns","keywords":"","version":"Next"},{"title":"known_false_negatives","type":0,"sectionRef":"#","url":"/docs/fb/known_false_negatives/","content":"known_false_negatives","keywords":"","version":"Next"},{"title":"models","type":0,"sectionRef":"#","url":"/docs/fb/models/","content":"models","keywords":"","version":"Next"},{"title":"overview","type":0,"sectionRef":"#","url":"/docs/fb/overview/","content":"overview","keywords":"","version":"Next"},{"title":"triaging_exploitability_issues","type":0,"sectionRef":"#","url":"/docs/fb/triaging_exploitability_issues/","content":"triaging_exploitability_issues","keywords":"","version":"Next"},{"title":"shims","type":0,"sectionRef":"#","url":"/docs/fb/shims/","content":"shims","keywords":"","version":"Next"},{"title":"Feature Glossary","type":0,"sectionRef":"#","url":"/docs/feature-descriptions/","content":"","keywords":"","version":"Next"},{"title":"Pre-configured features​","type":1,"pageTitle":"Feature Glossary","url":"/docs/feature-descriptions/#pre-configured-features","content":" via-caller-exported This feature is applied when the root callable is directly or indirectly called from an exported component defined in the Android manifest. For example, if the root callable is in the MainActivity and the MainActivity is exported, this feature will be attached. It is needed in order to determine if an Intent source is third-party controllable or not. This feature is sometimes accompanied by via-class which tells you which class Mariana Trench used to determine that the root callable is called from an exported class. via-caller-unexported Same as via-caller-exported but applied if the root callable is considered to be called only via unexported components via-caller-permission Similair to via-caller-exported but applied if the root callable paths to a manifest entry that has a protectionLevel or Android permission declared. via-explicit-intent Applied when the taint flow goes via a class or package name setter on an Intent. This can be used to infer whether a launched Intent can resolve to third party apps or only to a specifically defined app (implicit versus explicit intents). via-inner-class-this Anonymous classes in Java byte code transfer the taint from the parent class to the anonymous class via this.this$0 which can lead to broaden false positives. This feature can be used to filter out such flows when they are a common false positive pattern. cast:[...] Cast features such as cast:boolean are applied when the tainted data is converted to that specific type. This allows for example to filter out data flows such as taintedString.length() where the returned tainted integer may no longer be of interest. via-obscure Obscure methods are methods for which Mariana Trench doesn't have any byte code available. Therefore we generally apply taint-in-taint-out behaviour on these methods and add the feature via-obscure to tell the user that the data flow went along an obscure method. via-[...]-broadening Is applied when any of the four broaden operations is applied (see Models). ","version":"Next","tagName":"h2"},{"title":"Getting Started","type":0,"sectionRef":"#","url":"/docs/getting-started/","content":"","keywords":"","version":"Next"},{"title":"Prerequisites​","type":1,"pageTitle":"Getting Started","url":"/docs/getting-started/#prerequisites","content":" Mariana Trench requires a recent version of Python. On MacOS you can get a current version through homebrew:  $ brew install python3   On a Debian flavored Linux (Ubuntu, Mint, Debian), you can use apt-get:  $ sudo apt-get install python3 python3-pip python3-venv   This guide also assumes you have the Android SDK installed and an environment variable $ANDROID_SDK pointed to the location of the SDK.  For the rest of this guide, we assume that you are working inside of a virtual environment. You can set this up with  $ python3 -m venv ~/.venvs/mariana-trench $ source ~/.venvs/mariana-trench/bin/activate (mariana-trench)$   The name of the virtual environment in front of your shell prompt indicates that the virtual environment is active.  ","version":"Next","tagName":"h2"},{"title":"Installing Mariana Trench​","type":1,"pageTitle":"Getting Started","url":"/docs/getting-started/#installing-mariana-trench","content":" Inside your virtual environment installing Mariana Trench is as easy as running  (mariana-trench)$ pip install mariana-trench   ","version":"Next","tagName":"h2"},{"title":"Running Mariana Trench​","type":1,"pageTitle":"Getting Started","url":"/docs/getting-started/#running-mariana-trench","content":" We'll use a small app that is part of our documentation. You can get it by running  (mariana-trench)$ git clone https://github.com/facebook/mariana-trench (mariana-trench)$ cd mariana-trench/documentation/sample-app   We are now ready to run the analysis  (mariana-trench)$ mariana-trench \\ --system-jar-configuration-path=configuration/default_system_jar_paths.json \\ --model-generator-configuration-paths=configuration/default_generator_config.json \\ --lifecycles-paths=configuration/lifecycles.json \\ --rules-paths=configuration/rules.json \\ --apk-path=documentation/sample-app/app/build/outputs/apk/debug/app-debug.apk \\ --source-root-directory=documentation/sample-app/app/src/main/java \\ --model-generator-search-paths=configuration/model-generators/ # ... INFO Analyzed 68886 models in 4.04s. Found 4 issues! # ...   The analysis has found 4 issues in our sample app. The output of the analysis is a set of specifications for each method of the application.  ","version":"Next","tagName":"h2"},{"title":"Post Processing​","type":1,"pageTitle":"Getting Started","url":"/docs/getting-started/#post-processing","content":" The specifications themselves are not meant to be read by humans. We need an additional processing step in order to make the results more presentable. We do this with SAPP PyPi installed for us:  (mariana-trench)$ sapp --tool=mariana-trench analyze . (mariana-trench)$ sapp --database-name=sapp.db server --source-directory=app/src/main/java # ... 2021-05-12 12:27:22,867 [INFO] * Running on http://localhost:13337/ (Press CTRL+C to quit)   The last line of the output tells us that SAPP started a local webserver that lets us look at the results. Open the link and you will see the 4 issues found by the analysis.  ","version":"Next","tagName":"h2"},{"title":"Exploring Results​","type":1,"pageTitle":"Getting Started","url":"/docs/getting-started/#exploring-results","content":" Let's focus on the remote code execution issue found in the sample app. You can identify it by its issue code 1 (for all remote code executions) and the callable void MainActivity.onCreate(Bundle). With only 4 issues to see it's easy to identify the issue manually but once more rules run, the filter functionality at the top right of the page comes in handy.    The issue tells you that Mariana Trench found a remote code execution in MainActivity.onCreate where the data is coming from Activity.getIntent one call away, and flows into the constructor of ProcessBuilder 3 calls away. Click on &quot;Traces&quot; in the top right corner of the issue to see an example trace.  The trace surfaced by Mariana Trench consists of three parts.  The source trace represents where the data is coming from. In our example, the trace is very short: Activity.getIntent is called in MainActivity.onCreate directly.    The trace root represents where the source trace meets the sink trace. In our example this is the MainActivity.onCreate method.    The final part of the trace is the sink trace: This is where the data from the source flows down into a sink. In our example from onCreate, to onClick, to execute, and finally into the constructor of ProcessBuilder.    ","version":"Next","tagName":"h2"},{"title":"Configuring Mariana Trench​","type":1,"pageTitle":"Getting Started","url":"/docs/getting-started/#configuring-mariana-trench","content":" You might be asking yourself, &quot;how does the tool know what is user controlled data, and what is a sink?&quot;. This guide is meant to quickly get you started on a small app. We did not cover how to configure Mariana Trench. You can read more about that in the Configuration section. ","version":"Next","tagName":"h2"},{"title":"Known False Negatives","type":0,"sectionRef":"#","url":"/docs/known-false-negatives/","content":"","keywords":"","version":"Next"},{"title":"Trace too Long​","type":1,"pageTitle":"Known False Negatives","url":"/docs/known-false-negatives/#trace-too-long","content":" Mariana Trench stops propagating taint beyond a certain depth. This depth is currently configured at 7. In code:  // This method has depth 1. public int get_source_1() { return source(); } // This method has depth 2. public int get_source_2() { return get_source_1(); } ... // This method has depth 7. public int get_source_7() { return get_source_6(); } // This method theoretically has depth 8, but MT drops the source here. public int get_source_8() { return get_source_7(); }   Workaround: If the chain of wrappers obviously leads to a source or sink, instead of defining the source at source(), one could write an additional model marking get_source_7() as a source.  ","version":"Next","tagName":"h2"},{"title":"Fields of Fields of Fields of Fields...​","type":1,"pageTitle":"Known False Negatives","url":"/docs/known-false-negatives/#fields-of-fields-of-fields-of-fields","content":" Taint of an object is dropped when it occurs too deep within the object. This depth is configured at 4. In code:  public void taintedThis() { this.mField1 = source(); // This is OK this.mField1.mField2.mField3.mField4.mField5 = source(); // This gets dropped }   Workaround: This isn’t much of a workaround, but one can manually configure the source on “this.mField1.....mField4” instead. This will be a form of over-abstraction and could lead to false positives.  ","version":"Next","tagName":"h2"},{"title":"Fanouts​","type":1,"pageTitle":"Known False Negatives","url":"/docs/known-false-negatives/#fanouts","content":" If a virtual method has too many overrides, beyond a certain number (currently configured at 40), we stop considering all overrides and look only at the direct method being called. In code:  interface IFace { public int possibleSource(); } class Class1 implements IFace { public int possibleSource() { return 1; } } ... class Class41 implements IFace { public int possibleSource() { return source(); } } int maybeIssue(IFace iface) { // The source will get dropped here because there are too many overrides. // MT will not report an issue. sink(iface.possibleSource()); }   Workaround: Unfortunately, there are no known workarounds.  ","version":"Next","tagName":"h2"},{"title":"Propagation across Arguments​","type":1,"pageTitle":"Known False Negatives","url":"/docs/known-false-negatives/#propagation-across-arguments","content":" Mariana Trench computes propagations for each method (this may be known as “tito” (taint-in-taint-out) in other tools). Propagations tell the analysis that if an argument is tainted by a source, whether its return value, or the method’s “this” object become tainted by the argument. However, without explictly specifying --propagate-across-arguments, Mariana Trench does not propagate taint from one argument to another. In code:  void setIntentValue(Intent intent, Uri uri) { // MT sees that intent.putExtra has a propagation from uri (Argument(2)) to // intent (Argument(0) or this). intent.putExtra(&quot;label&quot;, uri); // However, when it finishes analyzing setIntentValue, it will not track the // propagation from uri to intent. } void falseNegative() { Uri uri = source(); Intent intent = new Intent(); // If this were the code, MT will detect a source-&gt;sink flow at launchActivitySink. // intent.putExtra(&quot;label&quot;, uri); // MT loses the flow from uri-&gt;intent at this point. setIntentValue(intent, uri); launchActivitySink(intent); }   Workaround 1: Write an explicit propagation model for the method. While Mariana Trench does not infer propagations across arguments, it does allow manual specification of such models.  Workaround 2: Enable --propagate-across-arguments, which enables taint propagation across method invocations for object. Note that the behaviour is enabled globally, meaning that this may incur a significant runtime and memory overhead.  ","version":"Next","tagName":"h2"},{"title":"Overview","type":0,"sectionRef":"#","url":"/docs/overview/","content":"","keywords":"","version":"Next"},{"title":"What is Mariana Trench​","type":1,"pageTitle":"Overview","url":"/docs/overview/#what-is-mariana-trench","content":" Mariana Trench is a security focused static analysis platform targeting Android. The tool provides an extensible global taint analysis similar to pre-existing tools like Pysa for Python. The tool leverages existing static analysis infrastructure (e.g, SPARTA) built on top of Redex.  By default Mariana Trench analyzes dalvik bytecode and can work with or without access to the source code.  ","version":"Next","tagName":"h2"},{"title":"Background​","type":1,"pageTitle":"Overview","url":"/docs/overview/#background","content":" ","version":"Next","tagName":"h2"},{"title":"Sources and Sinks​","type":1,"pageTitle":"Overview","url":"/docs/overview/#sources-and-sinks","content":" Under the context of taint analysis [1], &quot;sources&quot; usually mean sensitive data that originates from users. For example, sources can be users' passwords or locations. &quot;Sinks&quot; usually mean functions or methods that use data that &quot;flows&quot; from sources, where the term &quot;flow&quot; is generally defined under the context of &quot;information flow&quot; [2].  An operation, or series of operations, that uses the value of some object, say x, to derive a value for another, say y, causes a flow from x to y  As an example, sinks can be a logging API that writes data into a log file.  ","version":"Next","tagName":"h3"},{"title":"What does Mariana Trench do?​","type":1,"pageTitle":"Overview","url":"/docs/overview/#what-does-mariana-trench-do","content":" A flow from sources to sinks indicate that for example user passwords may get logged into a file, which is not desirable and is called as an &quot;issue&quot; under the context of Mariana Trench. Mariana Trench is designed to automatically discover such issues.  ","version":"Next","tagName":"h3"},{"title":"Usage​","type":1,"pageTitle":"Overview","url":"/docs/overview/#usage","content":" The usage of Mariana Trench can be summarized in three steps:  Specify customized &quot;sources&quot; and &quot;sinks&quot;. (See Customize Sources and Sinks)Run Mariana Trench on an arbitrary Java repository (with the sources and sinks specified in Step 1), whether it be a repository for an Android application project or for a vanilla (or plain old) Java project.View the analysis results from a web browser. (For steps 2 and 3 see Getting Started)    ","version":"Next","tagName":"h2"},{"title":"References​","type":1,"pageTitle":"Overview","url":"/docs/overview/#references","content":" Tripp, Omer, et al. &quot;TAJ: effective taint analysis of web applications.&quot; ACM Sigplan Notices 44.6 (2009): 87-97.Denning, Dorothy E., and Peter J. Denning. &quot;Certification of programs for secure information flow.&quot; Communications of the ACM 20.7 (1977): 504-513. ","version":"Next","tagName":"h2"},{"title":"Rules","type":0,"sectionRef":"#","url":"/docs/rules/","content":"","keywords":"","version":"Next"},{"title":"Transform Rules​","type":1,"pageTitle":"Rules","url":"/docs/rules/#transform-rules","content":" Some flows are only interesting if they also pass through a specific method. These methods can be modeled as a propagation with transforms. Then, to catch these flows, we specify the ordered list of transforms here in the rule.  Here is an example of a transform rule in JSON:  { &quot;name&quot;: &quot;URI Query Parameters flow into Internal Intent data&quot;, &quot;code&quot;: 2, &quot;oncall&quot;: &quot;prodsec_mobile&quot;, &quot;description&quot;: &quot;Values from a query parameter source may eventually flow into Internal Intent data&quot;, &quot;sources&quot;: [ &quot;UriQueryParameter&quot; ], &quot;transforms&quot;: [ &quot;IntentData&quot; ], &quot;sinks&quot;: [ &quot;LaunchingFamilyComponent&quot; ] }   The flow will only be created if UriQueryParameter flows through IntentData and then into LaunchingFamilyComponent. It will not be created when UriQueryParameter flows into LaunchingFamilyComponent without passing through the IntentData transform.  See Models and Model Generators for how to model transforms.  ","version":"Next","tagName":"h3"},{"title":"Multi-Source, Multi-Sink Rules​","type":1,"pageTitle":"Rules","url":"/docs/rules/#multi-source-multi-sink-rules","content":" Multi-source multi-sink rules are used to track the flow of taint from multiple sources to multiple sinks. This can, for example, be useful if you want to track both the source types &quot;SensitiveData&quot; and &quot;WorldReadableFileLocation&quot; to an IO operation as displayed in the code below.  File externalDir = context.getExternalFilesDir() // source WorldReadableFileLocation String sensitiveData = getUserToken() // source SensitiveData File outputFile = new File(externalDir, &quot;file.txt&quot;); try (FileOutputStream fos = new FileOutputStream(outputFile)) { fos.write(sensitiveData.getBytes()); // sink Argument(0) and Argument(1) }   Such a rule can be defined as follows:  Define the sources as usual (see documentation above).Define sinks on FileOutputStream::write as follows:  { &quot;model_generators&quot;: [ { &quot;find&quot;: &quot;methods&quot;, &quot;where&quot;: [ /* name = write */ ... ], &quot;model&quot;: { &quot;sink&quot;: [ { &quot;kind&quot;: &quot;PartialExternalFileWrite&quot;, &quot;partial_label&quot;: &quot;outputStream&quot;, &quot;port&quot;: &quot;Argument(0)&quot; }, { &quot;kind&quot;: &quot;PartialExternalFileWrite&quot;, &quot;partial_label&quot;: &quot;outputBytes&quot;, &quot;port&quot;: &quot;Argument(1)&quot; } ] } } }   Here, there is one sink method catching two sources flowing into it, turning it into a partial_sink.  To define each source that flows into the partial_sink:  kind must be the samepartial_label must be unique - this will map to the source in the rule definitionport must be unique - see port documentationThere must be as many partial_labels are there are multi_sources  NOTE: Multi-source/sink rules currently support exactly 2 sources/sinks only.  Define rules as follows:   { &quot;name&quot;: &quot;Experimental: Some name&quot;, &quot;code&quot;: 9001, &quot;description&quot;: &quot;More description here.&quot;, &quot;multi_sources&quot;: { &quot;outputBytes&quot;: [ &quot;SensitiveData&quot; ], &quot;outputStream&quot;: [ &quot;WorldReadableFileLocation&quot; ] }, &quot;partial_sinks&quot;: [ &quot;PartialExternalFileWrite&quot; ] }   Pay attention to how the labels and partial sink kinds match what is defined in the sinks above.  ","version":"Next","tagName":"h3"},{"title":"Exploitability Rules​","type":1,"pageTitle":"Rules","url":"/docs/rules/#exploitability-rules","content":" For android, some source to sink flows are only considered valid if the root callable of the source to sink flow is also accessible from outside the app. This access is controlled by exported setting in the manifest file. Exploitability rules allow us to additionally constraint source to sink rules on a call-chain flow from the root callable of the source to sink flow up to a call-chain effect source which is identified using the android manifest. Eg.  class ExportedActivity extends Activity { void onCreate() { Util.exploitabilityRootCallable(this); } } class Util { void exploitabilityRootCallable(Activity activity) { toSink(activity.getSource()); } }   Here, if we want to report an issue only if the android manifest sets exported: true for ExportedActivity. You can specify the explotability rule as follows:  { &quot;name&quot;: &quot;Source to sink flow is reachable from an exported class&quot;, &quot;code&quot;: 1, &quot;description&quot;: &quot;Values from source may eventually flow into sink&quot;, &quot;sources&quot;: [ &quot;ActivityUserInput&quot; ], &quot;effect_sources&quot;: [ &quot;Exported&quot; ], &quot;sinks&quot;: [ &quot;LaunchingComponent&quot; ] }   Here, source to sink flow is found in rootExploitabilityCallable() but the issue will be reported iff ExportedActivity has exported:true in the android manifest.   ExportedActivity::onCreate(): with effect_source: Exported | exploitabilityRootCallable(): with inferred effect_sink: | SourceAsTransform[ActivityUserInput]@LaunchingComponent +-----------------+-----------------+ | | getSource(): with toSink(): with source kind: ActivityUserInput sink kind: LaunchingComponent   ","version":"Next","tagName":"h3"},{"title":"Multi-Source, Multi-Sink Rules","type":0,"sectionRef":"#","url":"/docs/multi-source-sink-rules/","content":"","keywords":"","version":"Next"},{"title":"Multi-Source, Multi-Sink Rules​","type":1,"pageTitle":"Multi-Source, Multi-Sink Rules","url":"/docs/multi-source-sink-rules/#multi-source-multi-sink-rules","content":" Multi-source multi-sink rules are used to track the flow of taint from multiple sources to multiple sinks. This can, for example, be useful if you want to track both the source types &quot;SensitiveData&quot; and &quot;WorldReadableFileLocation&quot; to an IO operation as displayed in the code below.  File externalDir = context.getExternalFilesDir() // source WorldReadableFileLocation String sensitiveData = getUserToken() // source SensitiveData File outputFile = new File(externalDir, &quot;file.txt&quot;); try (FileOutputStream fos = new FileOutputStream(outputFile)) { fos.write(sensitiveData.getBytes()); // sink Argument(0) and Argument(1) }   Such a rule can be defined as follows:  Define the sources as usual (see documentation above).Define sinks on FileOutputStream::write as follows:  { &quot;model_generators&quot;: [ { &quot;find&quot;: &quot;methods&quot;, &quot;where&quot;: [ /* name = write */ ... ], &quot;model&quot;: { &quot;sink&quot;: [ { &quot;kind&quot;: &quot;PartialExternalFileWrite&quot;, &quot;partial_label&quot;: &quot;outputStream&quot;, &quot;port&quot;: &quot;Argument(0)&quot; }, { &quot;kind&quot;: &quot;PartialExternalFileWrite&quot;, &quot;partial_label&quot;: &quot;outputBytes&quot;, &quot;port&quot;: &quot;Argument(1)&quot; } ] } } }   Here, there is one sink method catching two sources flowing into it, turning it into a partial_sink.  To define each source that flows into the partial_sink:  kind must be the samepartial_label must be unique - this will map to the source in the rule definitionport must be unique - see port documentationThere must be as many partial_labels are there are multi_sources  NOTE: Multi-source/sink rules currently support exactly 2 sources/sinks only.  Define rules as follows:   { &quot;name&quot;: &quot;Experimental: Some name&quot;, &quot;code&quot;: 9001, &quot;description&quot;: &quot;More description here.&quot;, &quot;multi_sources&quot;: { &quot;outputBytes&quot;: [ &quot;SensitiveData&quot; ], &quot;outputStream&quot;: [ &quot;WorldReadableFileLocation&quot; ] }, &quot;partial_sinks&quot;: [ &quot;PartialExternalFileWrite&quot; ] }   Pay attention to how the labels and partial sink kinds match what is defined in the sinks above. ","version":"Next","tagName":"h3"},{"title":"Shims","type":0,"sectionRef":"#","url":"/docs/shims/","content":"","keywords":"","version":"Next"},{"title":"What is a \"shim\"?​","type":1,"pageTitle":"Shims","url":"/docs/shims/#what-is-a-shim","content":" We can think of a “shim” as the ability to say: &quot;a call to a method matching&lt;shimmed-method&gt; also implies calls to methods matching &lt;shim-target-1&gt;,&lt;shim-target-2&gt;, …, &lt;shim-target-n&gt;. This allows us to manually augment the call-graph with artificial calls to methods at specific call-sites. This is useful for simulating events in the android application by mimicking calls to the known event-handlers which allows us to capture dataflows otherwise missed due to the missing invocation of event-handlers.  For example, when a new fragment is added to a FragmentManager, theFragmentManager is responsible for moving them through its lifecycle states (reference). But we do not see the calls to the lifecycle event handlers on the new instance of the fragment and can miss flows. We can define shims as follows to fill in such missing links.  class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedinstanceState) { if (savedInstanceState == null) { Fragment myFragment = new MyFragment(); myFragment.setArguments(getTaintedBundle()); // Source getSupportFragmentManager().beginTransaction() .setReorderingAllowed(true) .add(R.id.fragment_container_view, myFragment, null) // FragmentManager handles `myFragment`'s lifecycle. .commit(); } } } class MyFragment extends Fragment { @Override public void onCreate(Bundle savedInstanceState) { sink(getArguments()); // Issue if `mArguments` is tainted using `setArguments()` } }   In this case, we can define a shim on FragmentTransaction's add() totrigger the lifecycle wrapper method of it's Fragment argument to mimic the android's lifecycle management to catch this flow.  { &quot;find&quot;: &quot;methods&quot;, &quot;where&quot;: [ { &quot;constraint&quot;: &quot;signature_pattern&quot;, &quot;pattern&quot;: &quot;Landroidx/fragment/app/FragmentTransaction;\\\\.add:\\\\(ILandroidx/fragment/app/Fragment;.*&quot; } ], &quot;shim&quot;: { &quot;callees&quot;: [ { &quot;type_of&quot;: &quot;Argument(2)&quot;, &quot;lifecycle_name&quot;: &quot;xfragment_lifecycle_wrapper&quot; } ] } },   ","version":"Next","tagName":"h2"},{"title":"Terminologies​","type":1,"pageTitle":"Shims","url":"/docs/shims/#terminologies","content":" shimmed-method: The method matching the &quot;where&quot; clause in the shim generator.shim-target: Method matching each of the &quot;callees&quot; object specified in the shim generator.parameters map: Mapping for arguments from shim-target to shimmed-method.  All callsites of the shimmed-method implies calls to all the shim-targetsspecified with arguments propagated from the shimmed-method to shim-target based on the parameters map.  ","version":"Next","tagName":"h2"},{"title":"Specifying Shims​","type":1,"pageTitle":"Shims","url":"/docs/shims/#specifying-shims","content":" ","version":"Next","tagName":"h2"},{"title":"Configuration file​","type":1,"pageTitle":"Shims","url":"/docs/shims/#configuration-file","content":" The Mariana Trench binary consumes shim configuration files specified with the argument --shims-paths. Each file contains a json array consisting of shim definitions. Default set of shims can found inshims.json  ","version":"Next","tagName":"h3"},{"title":"Shim Definition​","type":1,"pageTitle":"Shims","url":"/docs/shims/#shim-definition","content":" Each shim definition object consists of the following keys:  find: Currently only option is methods. where: A list of &quot;constraints&quot; which identifies the &quot;shimmed-method&quot;. This is same as in model generators. shim: A list of &quot;callees&quot; each of which identifies a &quot;shim-target&quot;. Each callees object needs to define the following: Receiver for the shim-target​ Receiver can be defined using one of the following keys: static: Used to specify static methods as shim-targets. Expected value: A string specifying the dex class containing the shim-target method. type_of: Used to specify an instance argument or the return value of the shimmed-method as the receiver. Expected value: A string specifying the port/access path of the shimmed-method. reflected_type_of: Used to specify a reflection argument of the shimmed-method as the receiver. Expected value: A string specifying the port/access path of the shimmed-method. The type of the specified shimmed-method argument must be: Ljava/lang/Class;. Method to call​ Method can be defined using one of the following keys: method_name: Used to specify an existing method of the receiver as the shim-target. Expected value: A string specifying the dex proto of the method. This is of the form: &lt;method name&gt;:(&lt;parameter types&gt;)&lt;return type&gt;. lifecycle_name: Used to specify lifecycle method specified using the option --lifecycles-paths as the shim-target. Expected value: A string matching the method_name specified in the lifecycle configuration. Parameters map (optional)​ A map specifying how the parameters of the shimmed-method should be propagated to the shim-target. If not specified, each argument of the shim-target is mapped to the first argument of the shimmed-method with the matching type. Expected format is as follows where the &quot;key&quot; refers to the shim-target and the value refers to the shimmed-method. &quot;parameters_map&quot;: { &quot;Argument(&lt;int&gt;)&quot;: &quot;Argument(&lt;int&gt;)&quot;, ... } The infer_parameters_from_types option can be used to control the behavior of inferring mapping based on parameter types. It behaves as follows: if parameters_map is not provided, the mapping is inferred by default.if parameters_map is provided if infer_parameters_from_types is set to true: Any remaining unspecified mappings will be inferred.if infer_parameters_from_types is not specified or set to false: the unspecified mapping of the remaining parameters are not inferred.  ","version":"Next","tagName":"h3"},{"title":"Example​","type":1,"pageTitle":"Shims","url":"/docs/shims/#example","content":" class TargetA { void methodA(Object o) {} } class TargetB { void methodB(Object o1, Object o2) {} } class TargetC { static void methodC(Object o) {} } class Shimmed { void shimMe(A a, Class b, Object o) {} } class Test { void test() { new Shimmed().shimMe(new TargetA(), TargetB.class, new Object()); } }   Shim definitions:  { &quot;find&quot;: &quot;methods&quot;, &quot;where&quot;: [ { &quot;constraint&quot;: &quot;signature_pattern&quot;, &quot;pattern&quot;: &quot;LShimmed;\\\\.shimMe:\\\\(LTargetA;Ljava/lang/Class;Ljava/lang/Object;\\\\)V&quot; } ], &quot;shim&quot;: { &quot;callees&quot;: [ { &quot;type_of&quot;: &quot;Argument(1)&quot;, &quot;method_name&quot;: &quot;methodA:(Ljava/lang/Object;)V&quot; }, { &quot;reflected_type_of&quot;: &quot;Argument(2)&quot;, &quot;method_name&quot;: &quot;methodB:(Ljava/lang/Object;Ljava/lang/Object;)V&quot;, &quot;parameters_map&quot;: { &quot;Argument(2)&quot;: &quot;Argument(3)&quot; } }, { &quot;static&quot;: &quot;LTargetC;&quot;, &quot;method_name&quot;: &quot;method:C(Ljava/lang/Object;)V&quot;, &quot;parameters_map&quot;: { &quot;Argument(0)&quot;: &quot;Argument(3)&quot; } } ] } },   With this shim definition, the call to method shimMe() on line X will introduce calls to:  LTargetA.methodA:(Ljava/lang/Object;)V where argument o is inferred to be Argument(3) of method LShimmed;.shimMe:(LTargetA;Ljava/lang/Class;Ljava/lang/Object;)V.LTargetB.methodB:(Ljava/lang/Object;)V where argument o2 is mapped to Argument(3) of method LShimmed;.shimMe:(LTargetA;Ljava/lang/Class;Ljava/lang/Object;)V as specified. Note that argument Class b of the shimmed-method is resolved to be TargetB at the callsite.LTargetC.methodC:()V where argument o is mapped to Argument(3) of method LShimmed;.shimMe:(LTargetA;Ljava/lang/Class;Ljava/lang/Object;)V as specified. Note here that we specify Argument(0) of the shim-target in the parameters_map as this is a static method.  Note that when issues are found due to taint flow through shimmed-method to shim-target, the trace following the call-site of the shimmed-method will be the shim-target and a feature via-shim:&lt;shimmed-method&gt; will be introduced at that point.  Sample shim definitions here.  ","version":"Next","tagName":"h3"},{"title":"Models & Model Generators","type":0,"sectionRef":"#","url":"/docs/models/","content":"","keywords":"","version":"Next"},{"title":"Models​","type":1,"pageTitle":"Models & Model Generators","url":"/docs/models/#models","content":" A model is an abstract representation of how data flows through a method.  A model essentialy consists of:  Sources: a set of sources that the method produces or receives on parameters;Sinks: a set of sinks on the method;Propagation: a description of how the method propagates taint coming into it (e.g, the first parameter updates the second, the second parameter updates the return value, etc.);Attach to Sources: a set of features/breadcrumbs to add on an any sources flowing out of the method;Attach to Sinks: a set of features/breadcrumbs to add on sinks of a given parameter;Attach to Propagations: a set of features/breadcrumbs to add on propagations for a given parameter or return value;Add Features to Arguments: a set of features/breadcrumbs to add on any taint that might flow in a given parameter;Sanitizers: specifications of taint flows to stop;Modes: a set of flags describing specific behaviors (see below).  Models can be specified in JSON. For example to mark the string parameter to our Logger.log function as a sink we can specify it as  { &quot;find&quot;: &quot;methods&quot;, &quot;where&quot;: [ { &quot;constraint&quot;: &quot;signature_match&quot;, &quot;parent&quot;: &quot;Lcom/example/Logger;&quot;, &quot;name&quot;: &quot;log&quot; } ], &quot;model&quot;: { &quot;sinks&quot;: [ { &quot;kind&quot;: &quot;Logging&quot;, &quot;port&quot;: &quot;Argument(1)&quot; } ] } }   Note that the naming of methods follow the Dalvik's bytecode format.  ","version":"Next","tagName":"h2"},{"title":"Method name format​","type":1,"pageTitle":"Models & Model Generators","url":"/docs/models/#method-name-format","content":" The format used for method names is:  &lt;className&gt;.&lt;methodName&gt;:(&lt;parameterType1&gt;&lt;parameterType2&gt;)&lt;returnType&gt;  Example: Landroidx/fragment/app/Fragment;.startActivity:(Landroid/content/Intent;)V  For the parameters and return types use the following table to pick the correct one (please refer to JVM doc for more details)  V - voidZ - booleanB - byteS - shortC - charI - intJ - long (64 bits)F - floatD - double (64 bits)  Classes take the form Lpackage/name/ClassName; - where the leading L indicates that it is a class type, package/name/ is the package that the class is in. A nested class will take the form Lpackage/name/ClassName$NestedClassName; (the $ will need to be double escaped \\\\$ in json regex).  ","version":"Next","tagName":"h3"},{"title":"Access path format​","type":1,"pageTitle":"Models & Model Generators","url":"/docs/models/#access-path-format","content":" An access path describes the symbolic location of a taint. This is commonly used to indicate where a source or a sink originates from. The &quot;port&quot; field of any model is represented by an access path.  An access path is composed of a root and a path.  The root is either:  Return, representing the returned value;Argument(x) (where x is an integer), representing the parameter number x. Note that Argument(0) represents the implicit this parameter for instance methods;  The path is a (possibly empty) list of path elements. A path element can be any of the following kinds:  field: represents a field name. String encoding is a dot followed by the field name: .field_name;index: represents a user defined index for dictionary like objects. String encoding uses square braces to enclose any user defined index: [index_name];any index: represents any or unresolved indices in dictionary like objects. String encoding is an asterisk enclosed in square braces: [*];index from value of: captures the value of the specified callable's port seen at its callsites during taint flow analysis as an index or any index (if the value cannot be resolved). String encoding uses argument root to specify the callable's port and encloses it in [&lt;...&gt;] to represent that its value is resolved at the callsite to create an index: [&lt;Argument(x)&gt;];  Examples:  Argument(1).name corresponds to the field name of the second parameter;Argument(1)[name] corresponds to the index name of the dictionary like second parameter;Argument(1)[*] corresponds to any index of the dictionary like second parameter;Argument(1)[&lt;Argument(2)&gt;] corresponds to an index of the dictionary like second parameter whose value is resolved from the third parameter;Return corresponds to the returned value;Return.x corresponds to the field x of the returned value;  NOTE 1: Instance (i.e, non-static) method parameters are indexed starting from 1! The 0th parameter is the this parameter in Dalvik byte-code. For static method parameters, indices start from 0.  NOTE 2: In a constructor (&lt;init&gt; method), parameters are also indexed starting from 1. The 0th parameter refers to the instance being constructed, similar to the this reference.  ","version":"Next","tagName":"h3"},{"title":"Kinds​","type":1,"pageTitle":"Models & Model Generators","url":"/docs/models/#kinds","content":" A source has a kind that describes its content (e.g, user input, file system, etc). A sink also has a kind that describes the operation the method performs (e.g, execute a command, read a file, etc.). Kinds can be arbitrary strings (e.g, UserInput). We usually avoid whitespaces.  ","version":"Next","tagName":"h3"},{"title":"Sources​","type":1,"pageTitle":"Models & Model Generators","url":"/docs/models/#sources","content":" Sources describe taint produced or received by a given method. A source has a kind that describes its content (e.g, user input, file system, etc).  A method produces a source kind if invoking the method implies the source kind flows out from it. The source kind can flow out via the return value or through a parameter (pass by reference semantics).A method receives a source kind if a source kind is always assumed to flow in via an argument regardless of the method's callsite.  Here is an example where the source flows out through the return value:  public static String getPath() { return System.getenv().get(&quot;PATH&quot;); }   The JSON model generator for this method could be:  { &quot;find&quot;: &quot;methods&quot;, &quot;where&quot;: [ { &quot;constraint&quot;: &quot;signature_match&quot;, &quot;parent&quot;: &quot;Lcom/example/Class;&quot;, &quot;name&quot;: &quot;getPath&quot; } ], &quot;model&quot;: { &quot;sources&quot;: [ { &quot;kind&quot;: &quot;UserControlled&quot;, &quot;port&quot;: &quot;Return&quot; } ] } }   Here is an example where the source flows in via an argument:  class MyActivity extends Activity { public void onNewIntent(Intent intent) { // intent should be considered a source here. } }   The JSON model generator for this method could be:  { &quot;find&quot;: &quot;methods&quot;, &quot;where&quot;: [ { &quot;constraint&quot;: &quot;signature_match&quot;, &quot;extends&quot;: &quot;Landroid/app/Activity&quot;, &quot;name&quot;: &quot;onNewIntent&quot; } ], &quot;model&quot;: { &quot;sources&quot;: [ { &quot;kind&quot;: &quot;UserControlled&quot;, &quot;port&quot;: &quot;Argument(1)&quot; } ] } }   Here is an example where source flows out via an argument:  public static void updateIntent(Intent intent) {} void createAndUseIntent() { MyIntent myIntent = new MyIntent(); // myIntent is not a source. This is safe. sink(myIntent); updateIntent(myIntent); // myIntent is now a source. This is now a flow. sink(myIntent); }   The JSON model generator for this method could be:  { &quot;find&quot;: &quot;methods&quot;, &quot;where&quot;: [ { &quot;constraint&quot;: &quot;signature_match&quot;, &quot;parent&quot;: &quot;Lcom/example/Class;&quot;, &quot;name&quot;: &quot;updateIntent&quot; } ], &quot;model&quot;: { &quot;generations&quot;: [ { &quot;kind&quot;: &quot;UserControlled&quot;, &quot;port&quot;: &quot;Argument(0)&quot; } ] } }   Note on the use of &quot;generations&quot; vs &quot;sources&quot;: &quot;generations&quot; indicates that the source kind is produced and flows out via the specified port. When the port is &quot;Return&quot;, &quot;generations&quot; and &quot;sources&quot; are equivalent.  &quot;generations&quot; are also useful to mark the this reference of an instance as sources. Instances are created using constructors, which are special &lt;init&gt; methods with return type void. But, as mentioned in Note 2 above, constructors create a special 0th parameter to refer to the instance being constructed (i.e. this). Here is an example where a constructor marks the instance as a source:  class SourceIntent extends Intent { SourceIntent() {} } void createAndUseIntent() { SourceIntent sourceIntent = new SourceIntent(); // sourceIntent is a source. sink(myIntent); }   The JSON model generator for the constructor method could be:  { &quot;find&quot;: &quot;methods&quot;, &quot;where&quot;: [ { &quot;constraint&quot;: &quot;signature_match&quot;, &quot;parent&quot;: &quot;Lcom/example/SourceIntent;&quot;, &quot;name&quot;: &quot;&lt;init&gt;&quot; } ], &quot;model&quot;: { &quot;generations&quot;: [ { &quot;kind&quot;: &quot;UserControlled&quot;, &quot;port&quot;: &quot;Argument(0)&quot; } ] } }   ","version":"Next","tagName":"h3"},{"title":"Sinks​","type":1,"pageTitle":"Models & Model Generators","url":"/docs/models/#sinks","content":" Sinks describe dangerous or sensitive methods in the code. A sink has a kind that represents the type of operation the method does (e.g, command execution, file system operation, etc). A sink must be attached to a given parameter of the method. A method can have multiple sinks.  Here is an example of a sink:  public static String readFile(String path, String extension, int mode) { // Return the content of the file path.extension }   Since path and extension can be used to read arbitrary files, we consider them sinks. We do not consider mode as a sink since we do not care whether the user can control it. The JSON model generator for this method could be:  { &quot;find&quot;: &quot;methods&quot;, &quot;where&quot;: [ { &quot;constraint&quot;: &quot;signature_match&quot;, &quot;parent&quot;: &quot;Lcom/example/Class&quot;, &quot;name&quot;: &quot;readFile&quot; } ], &quot;model&quot;: { &quot;sinks&quot;: [ { &quot;kind&quot;: &quot;FileRead&quot;, &quot;port&quot;: &quot;Argument(0)&quot; }, { &quot;kind&quot;: &quot;FileRead&quot;, &quot;port&quot;: &quot;Argument(1)&quot; } ] } }   ","version":"Next","tagName":"h3"},{"title":"Return Sinks​","type":1,"pageTitle":"Models & Model Generators","url":"/docs/models/#return-sinks","content":" Return sinks can be used to describe that a method should not return tainted information. A return sink is just a normal sink with a Return port.  ","version":"Next","tagName":"h3"},{"title":"Propagation​","type":1,"pageTitle":"Models & Model Generators","url":"/docs/models/#propagation","content":" Propagations − also called tito (Taint In Taint Out) or passthrough in other tools − describe how the method propagates taint. A propagation as an input (where the taint comes from) and an output (where the taint is moved to).  Here is an example of a propagation:  public static String concat(String x, String y) { return x + y; }   The return value of the method can be controlled by both parameters, hence it has the propagations Argument(0) -&gt; Return and Argument(1) -&gt; Return. The JSON model generator for this method could be:  { &quot;find&quot;: &quot;methods&quot;, &quot;where&quot;: [ { &quot;constraint&quot;: &quot;signature_match&quot;, &quot;parent&quot;: &quot;Lcom/example/Class&quot;, &quot;name&quot;: &quot;concat&quot; } ], &quot;model&quot;: { &quot;propagation&quot;: [ { &quot;input&quot;: &quot;Argument(0)&quot;, &quot;output&quot;: &quot;Return&quot; }, { &quot;input&quot;: &quot;Argument(1)&quot;, &quot;output&quot;: &quot;Return&quot; } ] } }   Propagation with Transforms​  Propagations can additionally specify a list of &quot;transforms&quot;. This is an ordered list of transform kinds which specifies the transformations that are applied to the input of the propagation. Transform kinds can be used to specify methods that flows must pass through to be valid flows. Transform kinds, like source and sink kinds, must be included as a part of the rule to add the transform constraint.  &quot;propagation&quot;: [ { &quot;input&quot;: &quot;Argument(0)&quot;, &quot;output&quot;: &quot;Return&quot;, &quot;transforms&quot;: [ &quot;IntentData&quot; ] } ]   ","version":"Next","tagName":"h3"},{"title":"Features​","type":1,"pageTitle":"Models & Model Generators","url":"/docs/models/#features","content":" Features (also called breadcrumbs) can be used to tag a flow and help filtering issues. A feature describes a property of a flow. A feature can be any arbitrary string.  For instance, the feature via-numerical-operator is used to describe that the data flows through a numerical operator such as an addition.  Features are very useful to filter flows in the SAPP UI. E.g. flows with a cast from string to integer are can sometimes be less important during triaging since controlling an integer is more difficult to exploit than controlling a full string.  Note that features do not stop the flow, they just help triaging.  Attach to Sources​  Attach to sources is used to add a set of features on any sources flowing out of a method through a given parameter or return value.  For instance, if we want to add the feature via-signed to all sources flowing out of the given method:  public String getSignedCookie();   We could use the following JSON model generator:  { &quot;find&quot;: &quot;methods&quot;, &quot;where&quot;: [ { &quot;constraint&quot;: &quot;signature_match&quot;, &quot;parent&quot;: &quot;Lcom/example/Class&quot;, &quot;name&quot;: &quot;getSignedCookie&quot; } ], &quot;model&quot;: { &quot;attach_to_sources&quot;: [ { &quot;features&quot;: [ &quot;via-signed&quot; ], &quot;port&quot;: &quot;Return&quot; } ] } }   Note that this is only useful for sources inferred by the analysis. If you know that getSignedCookie returns a source of a given kind, you should use a source instead.  Attach to Sinks​  Attach to sinks is used to add a set of features on all sinks on the given parameter of a method.  For instance, if we want to add the feature via-user on all sinks of the given method:  class User { public static User findUser(String username) { // The code here might use SQL, Thrift, or anything. We don't need to know. } }   We could use the following JSON model generator:  { &quot;find&quot;: &quot;methods&quot;, &quot;where&quot;: [ { &quot;constraint&quot;: &quot;signature_match&quot;, &quot;parent&quot;: &quot;Lcom/example/User&quot;, &quot;name&quot;: &quot;findUser&quot; } ], &quot;model&quot;: { &quot;attach_to_sinks&quot;: [ { &quot;features&quot;: [ &quot;via-user&quot; ], &quot;port&quot;: &quot;Argument(0)&quot; } ] } }   Note that this is only useful for sinks inferred by the analysis. If you know that findUser is a sink of a given kind, you should use a sink instead.  Attach to Propagations​  Attach to propagations is used to add a set of features on all propagations from or to a given parameter or return value of a method.  For instance, if we want to add the feature via-concat to the propagations of the given method:  public static String concat(String x, String y);   We could use the following JSON model generator:  { &quot;find&quot;: &quot;methods&quot;, &quot;where&quot;: [ { &quot;constraint&quot;: &quot;signature_match&quot;, &quot;parent&quot;: &quot;Lcom/example/Class&quot;, &quot;name&quot;: &quot;concat&quot; } ], &quot;model&quot;: { &quot;attach_to_propagations&quot;: [ { &quot;features&quot;: [ &quot;via-concat&quot; ], &quot;port&quot;: &quot;Return&quot; // We could also use Argument(0) and Argument(1) } ] } }   Note that this is only useful for propagations inferred by the analysis. If you know that concat has a propagation, you should model it as a propagation directly.  Add Features to Arguments​  Add features to arguments is used to add a set of features on all sources that might flow on a given parameter of a method.  Add features to arguments implies Attach to sources, Attach to sinks and Attach to propagations, but it also accounts for possible side effects at call sites.  For instance:  public static void log(String message) { System.out.println(message); } public void buyView() { String username = getParameter(&quot;username&quot;); String product = getParameter(&quot;product&quot;); log(username); buy(username, product); }   Technically, the log method doesn't have any source, sink or propagation. We can use add features to arguments to add a feature was-logged on the flow from getParameter(&quot;username&quot;) to buy(username, product). We could use the following JSON model generator for the log method:  { &quot;find&quot;: &quot;methods&quot;, &quot;where&quot;: [ { &quot;constraint&quot;: &quot;signature_match&quot;, &quot;parent&quot;: &quot;Lcom/example/Class&quot;, &quot;name&quot;: &quot;log&quot; } ], &quot;model&quot;: { &quot;add_features_to_arguments&quot;: [ { &quot;features&quot;: [ &quot;was-logged&quot; ], &quot;port&quot;: &quot;Argument(0)&quot; } ] } }   Via-type Features​  Via-type features are used to keep track of the type of a callable’s port seen at its callsites during taint flow analysis. They are specified in model generators within the “sources” or “sinks” field of a model with the “via_type_of” field. It is mapped to a nonempty list of ports of the method for which we want to create via-type features.  For example, if we were interested in the specific Activity subclasses with which the method below was called:   public void startActivityForResult(Intent intent, int requestCode); // At some callsite: ActivitySubclass activitySubclassInstance; activitySubclassInstance.startActivityForResult(intent, requestCode);   we could use the following JSON to specify a via-type feature that would materialize as via-type:ActivitySubclass:  { &quot;find&quot;: &quot;methods&quot;, &quot;where&quot;: [ { &quot;constraint&quot;: &quot;signature_match&quot;, &quot;extends&quot;: &quot;Landroid/app/Activity&quot;, &quot;name&quot;: &quot;startActivityForResult&quot; } ], &quot;model&quot;: { &quot;sinks&quot;: [ { &quot;port&quot;: &quot;Argument(1)&quot;, &quot;kind&quot;: &quot;SinkKind&quot;, &quot;via_type_of&quot;: [ &quot;Argument(0)&quot; ] } ] } }   Via-value Features​  Via-value feature captures the value of the specified callable's port seen at its callsites during taint flow analysis. They are specified similar to Via-type features -- in model generators within the &quot;sources&quot;, &quot;sinks&quot; or &quot;add_features_to_arguments&quot; field of a model with the &quot;via_value_of&quot; field. It is mapped to a nonempty list of ports of the method for which we want to create via-value features.  For example, if we were interested in the specific mode with which the method below was called:  public void log(String mode, String message); class Constants { public static final String MODE = &quot;M1&quot;; } // At some callsite: log(Constants.MODE, &quot;error message&quot;);   we could use the following JSON to specify a via-value feature that would materialize as via-value:M1:  { &quot;find&quot;: &quot;methods&quot;, &quot;where&quot;: [ { &quot;constraint&quot;: &quot;signature_match&quot;, &quot;parent&quot;: &quot;Lcom/example/Class&quot;, &quot;name&quot;: &quot;log&quot; } ], &quot;model&quot;: { &quot;sinks&quot;: [ { &quot;port&quot;: &quot;Argument(1)&quot;, &quot;kind&quot;: &quot;SinkKind&quot;, &quot;via_value_of&quot;: [ &quot;Argument(0)&quot; ] } ] } }   Note that this only works for numeric and string literals. In cases where the argument is not a constant, the feature will appear as via-value:unknown.  Note: via_type_of and via_value_of allow specifying a tag, which will be provided in the instantiated breadcrumb. For instance via-foo-value:bar, for a tag &quot;foo&quot;. This can be used to differentiate from other via-value or via-type breadcrumbs.  &quot;via_type_of&quot;: [ { &quot;port&quot;: &quot;Argument(1)&quot;, &quot;tag&quot;: &quot;differentiator&quot; } ]   This would create the feature via-differentiator-type:Lcom/example/Class.  For backward compatibility, we allow these to be mixed with normal ports in a list  &quot;via_value_of&quot;: [ &quot;Argument(0)&quot;, { &quot;port&quot;: &quot;Argument(1)&quot;, &quot;tag&quot;: &quot;error-mode&quot; }, &quot;Argument(2)&quot; ]   Annotation Features​  In model generators we can also use annotation features, which translate to regular user features based on annotation parameter values. This feature is also compatible with for_all_parameters.  Config example:  { &quot;model_generators&quot;: [ { &quot;find&quot;: &quot;methods&quot;, &quot;where&quot;: [ { &quot;constraint&quot;: &quot;signature_match&quot;, &quot;parent&quot;: &quot;Lcom/facebook/marianatrench/integrationtests/AnnotationFeature;&quot;, &quot;name&quot;: &quot;getSourceWithMethodAnnotation&quot; } ], &quot;model&quot;: { &quot;generations&quot;: [ { &quot;kind&quot;: &quot;Source&quot;, &quot;port&quot;: &quot;Return&quot;, &quot;via_annotation&quot;: [ { &quot;type&quot;: &quot;Lcom/facebook/marianatrench/integrationtests/Path;&quot;, &quot;target&quot;: &quot;Return&quot; } ] } ] } }, { &quot;find&quot;: &quot;methods&quot;, &quot;where&quot;: [ { &quot;constraint&quot;: &quot;signature_match&quot;, &quot;parent&quot;: &quot;Lcom/facebook/marianatrench/integrationtests/AnnotationFeature;&quot;, &quot;name&quot;: &quot;getSourceWithParameterAnnotation&quot; } ], &quot;model&quot;: { &quot;generations&quot;: [ { &quot;kind&quot;: &quot;Source&quot;, &quot;port&quot;: &quot;Return&quot;, &quot;via_annotation&quot;: [ { &quot;type&quot;: &quot;Lcom/facebook/marianatrench/integrationtests/QueryParam;&quot;, &quot;target&quot;: &quot;Argument(1)&quot; }, { &quot;type&quot;: &quot;Lcom/facebook/marianatrench/integrationtests/OtherQueryParam;&quot;, &quot;target&quot;: &quot;Argument(2)&quot;, &quot;tag&quot;: &quot;ParameterNameLabel&quot;, &quot;annotation_parameter&quot;: &quot;description&quot; } ] } ] } } ] }   Java class with annotations:  public class AnnotationFeature { @Path(&quot;/issue_1&quot;) Object getSourceWithMethodAnnotation() { return new Object(); } Object getSourceWithParameterAnnotation(@QueryParam(&quot;query_param_name&quot;) String value, @OtherQueryParam(value = &quot;other_query_param_name&quot;, description = &quot;other_query_param_name_description&quot;) String description) { return &quot;unrelated&quot;; } void testSourceWithMethodAnnotation() { Object source = getSourceWithMethodAnnotation(); Origin.sink(source); } void testSourceWithParameterAnnotation() { Object source = getSourceWithParameterAnnotation(&quot;argument_value&quot;); Origin.sink(source); } }   Resulting issues:  { &quot;issues&quot; : [ { &quot;always_features&quot; : [ &quot;via-annotation:/issue_1&quot; ], &quot;callee&quot; : &quot;Lcom/facebook/marianatrench/integrationtests/Origin;.sink:(Ljava/lang/Object;)V&quot;, ... { &quot;issues&quot; : [ { &quot;always_features&quot; : [ &quot;via-ParameterNameLabel-annotation:description_instead_of_value&quot; ], &quot;callee&quot; : &quot;Lcom/facebook/marianatrench/integrationtests/Origin;.sink:(Ljava/lang/Object;)V&quot;, ...   ","version":"Next","tagName":"h3"},{"title":"Taint Broadening​","type":1,"pageTitle":"Models & Model Generators","url":"/docs/models/#taint-broadening","content":" Taint broadening (also called collapsing) happens when Mariana Trench needs to make an approximation about a taint flow. It is the operation of reducing a taint tree into a single element. A taint tree is a tree where edges are field names and nodes are taint element. This is how Mariana Trench represents internally which fields (or sequence of fields) are tainted.  For instance, analyzing the following code:  MyClass var = new MyClass(); var.a = sourceX(); var.b.c = sourceY(); var.b.d = sourceZ();   The taint tree of variable var would be:   . a / \\ b { X } . c / \\ d { Y } { Z }   After collapsing, the tree is reduced to a single node { X, Y, Z }, which is less precise.  In conclusion, taint broadening effectively leads to considering the whole object as tainted while only some specific fields were initially tainted. This might happen for the correctness of the analysis or for performance reasons.  In the following sections, we will discuss when collapsing can happen. In most cases, a feature is automatically added on collapsed taint to help detect false positives.  Propagation Broadening​  Taint collapsing is applied when taint is propagated through a method.  For instance:  MyClass input = new MyClass(); input.a = SourceX(); MyClass output = SomeClass.UnknownMethod(input); Sink(output.b); // Considered an issue since `output` is considered tainted. This could be a False Negative without collapsing.   In that case, the feature via-propagation-broadening will be automatically added on the taint. This can help identify false positives.  If you know that this method preserves the structure of the parameter, you could specify a model and disable collapsing using the collapse attribute within a propagation:  { &quot;find&quot;: &quot;methods&quot;, &quot;where&quot;: [ { &quot;constraint&quot;: &quot;signature_match&quot;, &quot;parent&quot;: &quot;Lcom/example/SomeClass&quot;, &quot;name&quot;: &quot;UnknownMethod&quot; } ], &quot;model&quot;: { &quot;propagation&quot;: [ { &quot;input&quot;: &quot;Argument(0)&quot;, &quot;output&quot;: &quot;Return&quot;, &quot;collapse&quot;: false } ] } }   Note that Mariana Trench can usually infer when a method propagates taint without collapsing it when it has access to the code of that method and subsequent calls. For instance:  public String identity(String x) { // Automatically infers a propagation `Arg(0) -&gt; Return` with `collapse=false` return x; }   Issue Broadening Feature​  The via-issue-broadening feature is added to issues where the taint flowing into the sink was not held directly on the object passed in but on one of its fields. For example:  Class input = new Class(); input.field = source(); sink(input); // `input` is not tainted, but `input.field` is tainted and creates an issue   Widen Broadening Feature​  For performance reasons, if a given taint tree becomes very large (either in depth or in number of nodes at a given level), Mariana Trench collapses the tree to a smaller size. In these cases, the via-widen-broadening feature is added to the collapsed taint  Class input = new Class(); if (\\* condition *\\) { input.field1 = source(); input.field2 = source(); ... } else { input.fieldA = source(); input.fieldB = source(); ... } sink(input); // Too many fields are sources so the whole input object becomes tainted   ","version":"Next","tagName":"h3"},{"title":"Sanitizers​","type":1,"pageTitle":"Models & Model Generators","url":"/docs/models/#sanitizers","content":" Specifying sanitizers on a model allow us to stop taint flowing through that method. In Mariana Trench, they can be one of three types -  sources: prevent any taint sources from flowing out of the methodsinks: prevent taint from reaching any sinks within the methodpropagations: prevent propagations from being inferred between any two ports of the method.  These can be specified in model generators as follows -  { &quot;find&quot;: &quot;methods&quot;, &quot;where&quot;: ..., &quot;model&quot;: { &quot;sanitizers&quot;: [ { &quot;sanitize&quot;: &quot;sources&quot; }, { &quot;sanitize&quot;: &quot;sinks&quot; }, { &quot;sanitize&quot;: &quot;propagations&quot; } ], ... } }   Note, if there are any user-specified sources, sinks or propagations on the model, sanitizers will not affect them, but it will prevent them from being propagated outward to callsites.  Kind-specific Sanitizers​  sources and sinks sanitizers may include a list of kinds (each with or without a partial_label) to restrict the sanitizer to only sanitizing taint of those kinds. (When unspecified, as in the example above, all taint is sanitized regardless of kind).  &quot;sanitizers&quot;: [ { &quot;sanitize&quot;: &quot;sinks&quot;, &quot;kinds&quot;: [ { &quot;kind&quot;: &quot;SinkKindA&quot; }, { &quot;kind&quot;: &quot;SinkKindB&quot;, &quot;partial_label&quot;: &quot;A&quot; } ] } ]   Port-specific Sanitizers​  Sanitizers can also specify a specific port (access path root) they sanitize (ignoring all the rest). This field port has a slightly different meaning for each kind of sanitizer -  sources: represents the output port through which sources may not leave the methodsinks: represents the input port through which taint may not trigger any sinks within the modelpropagations: represents the input port through which a propagation to any other port may not be inferred  For example if the following method  public void someMethod(Object argument1, Object argument2) { toSink(argument1); toSink(argument2); }   had the following sanitizer in its model,  &quot;sanitizers&quot;: [ { &quot;sanitize&quot;: &quot;sinks&quot;, &quot;port&quot;: &quot;Argument(1)&quot; } ]   Then a source flowing into argument1 would be able to cause an issue, but not a source flowing into argument2.  Kind and port specifications may be included in the same sanitizer.  ","version":"Next","tagName":"h3"},{"title":"Modes​","type":1,"pageTitle":"Models & Model Generators","url":"/docs/models/#modes","content":" Modes are used to describe specific behaviors of methods. Available modes are:  skip-analysis: skip the analysis of the method;add-via-obscure-feature: add a feature/breadcrumb called via-obscure:&lt;method&gt; to sources flowing through this method;taint-in-taint-out: propagate the taint on arguments to the return value;taint-in-taint-this: propagate the taint on arguments into the this parameter;no-join-virtual-overrides: do not consider all possible overrides when handling a virtual call to this method;no-collapse-on-propagation: do not collapse input paths when applying propagations;alias-memory-location-on-invoke: aliases existing memory location at the callsite instead of creating a new one;strong-write-on-propagation: performs a strong write from input path to the output path on propagation;  ","version":"Next","tagName":"h3"},{"title":"Default model​","type":1,"pageTitle":"Models & Model Generators","url":"/docs/models/#default-model","content":" A default model is created for each method, except if it is provided by a model generator. The default model has a set of heuristics:  If the method has no source code, the model is automatically marked with the modes skip-analysis and add-via-obscure-feature.  If the method has more than 40 overrides, it is marked with the mode no-join-virtual-overrides.  Otherwise, the default model is empty (no sources/sinks/propagations).  ","version":"Next","tagName":"h3"},{"title":"Field Models​","type":1,"pageTitle":"Models & Model Generators","url":"/docs/models/#field-models","content":" These models represent user-defined taint on class fields (as opposed to methods, as described in all the previous sections on this page). They are specified in a similar way to method models as described below.  NOTE: Field sources should not be applied to fields that are both final and of a primitive type (int, char, float, etc as well as java.lang.String) as the Java compiler optimizes accesses of these fields in the bytecode into accesses of the constant value they hold. In this scenario, Mariana Trench has no way of recognizing that the constant was meant to carry a source.  Example field model generator for sources:  { &quot;find&quot;: &quot;fields&quot;, &quot;where&quot;: [ { &quot;constraint&quot;: &quot;name&quot;, &quot;pattern&quot;: &quot;SOURCE_EXAMPLE&quot; } ], &quot;model&quot;: { &quot;sources&quot; : [ { &quot;kind&quot;: &quot;FieldSource&quot; } ] } }   Example code:  public class TestClass { // Field that we know to be tainted public Object SOURCE_EXAMPLE = ...; void flow() { sink(EXAMPLE, ...); } }   Example field model generator for sinks:  { &quot;find&quot;: &quot;fields&quot;, &quot;where&quot;: [ { &quot;constraint&quot;: &quot;name&quot;, &quot;pattern&quot;: &quot;SINK_EXAMPLE&quot; } ], &quot;model&quot;: { &quot;sinks&quot; : [ { &quot;kind&quot;: &quot;FieldSink&quot; } ] } }   Example code:  public class TestClass { public Object SINK_EXAMPLE = ...; void flow() { SINK_EXAMPLE = source(); } }   Field signature formats follow the Dalvik bytecode format similar to methods as discussed above. This is of the form &lt;className&gt;.&lt;fieldName&gt;:&lt;fieldType&gt;.  ","version":"Next","tagName":"h3"},{"title":"Literal Models​","type":1,"pageTitle":"Models & Model Generators","url":"/docs/models/#literal-models","content":" Literal models represent user-defined taints on string literals matching configurable regular expressions. They can only be configured as sources and are intended to identify suspicious patterns, such as user-controlled data being concatenated with a string literal which looks like an SQL query.  NOTE: Each use of a literal in the analysed code which matches a pattern in a literal model will generate a new taint which needs to be explored by Mariana Trench. Using overly broad patterns like .* should thus be avoided, as they can lead to poor performance and high memory usage.  Example literal models:  [ { &quot;pattern&quot;: &quot;SELECT \\\\*.*&quot;, &quot;description&quot;: &quot;Potential SQL Query&quot;, &quot;sources&quot;: [ { &quot;kind&quot;: &quot;SqlQuery&quot; } ] }, { &quot;pattern&quot;: &quot;AI[0-9A-Z]{16}&quot;, &quot;description&quot;: &quot;Suspected Google API Key&quot;, &quot;sources&quot;: [ { &quot;kind&quot;: &quot;GoogleAPIKey&quot; } ] } ]   Example code:  void testRegexSource() { String prefix = &quot;SELECT * FROM USERS WHERE id = &quot;; String aci = getAttackerControlledInput(); String query = prefix + aci; // Sink } void testRegexSourceGoogleApiKey() { String secret = &quot;AIABCD1234EFGH5678&quot;; sink(secret); }   ","version":"Next","tagName":"h3"},{"title":"Model Generators​","type":1,"pageTitle":"Models & Model Generators","url":"/docs/models/#model-generators","content":" Mariana Trench allows for dynamic model specifications. This allows a user to specify models of methods before running the analysis. This is used to specify sources, sinks, propagation and modes.  The model generator files must have the extension .models. The locations to search for these files must be provided using the --model-generator-search-paths argument.  Model generators to use during analysis are listed in a model generator configuration file and specified using the --model-generator-configuration-paths argument. By default, we use default_generator_config.json. Any other .models files found in the search paths but not listed in the configuration file are ignored.  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Models & Model Generators","url":"/docs/models/#example","content":" Examples of model generators are located in the configuration/model-generators directory.  Below is an example of a JSON model generator:  { &quot;model_generators&quot;: [ { &quot;find&quot;: &quot;methods&quot;, &quot;where&quot;: [{&quot;constraint&quot;: &quot;name&quot;, &quot;pattern&quot;: &quot;toString&quot;}], &quot;model&quot;: { &quot;propagation&quot;: [ { &quot;input&quot;: &quot;Argument(0)&quot;, &quot;output&quot;: &quot;Return&quot; } ] } }, { &quot;find&quot;: &quot;methods&quot;, &quot;where&quot;: [ { &quot;constraint&quot;: &quot;parent&quot;, &quot;inner&quot;: { &quot;constraint&quot;: &quot;extends&quot;, &quot;inner&quot;: { &quot;constraint&quot;: &quot;name&quot;, &quot;pattern&quot;: &quot;SandcastleCommand&quot; } } }, {&quot;constraint&quot;: &quot;name&quot;, &quot;pattern&quot;: &quot;Time&quot;} ], &quot;model&quot;: { &quot;sources&quot;: [ { &quot;kind&quot;: &quot;Source&quot;, &quot;port&quot;: &quot;Return&quot; } ] } }, { &quot;find&quot;: &quot;methods&quot;, &quot;where&quot;: [ { &quot;constraint&quot;: &quot;parent&quot;, &quot;inner&quot;: { &quot;constraint&quot;: &quot;extends&quot;, &quot;inner&quot;: {&quot;constraint&quot;: &quot;name&quot;, &quot;pattern&quot;: &quot;IEntWithPurposePolicy&quot;} } }, {&quot;constraint&quot;: &quot;name&quot;, &quot;pattern&quot;: &quot;gen.*&quot;}, { &quot;constraint&quot;: &quot;parameter&quot;, &quot;idx&quot;: 0, &quot;inner&quot;: { &quot;constraint&quot;: &quot;type&quot;, &quot;kind&quot;: &quot;extends&quot;, &quot;class&quot;: &quot;IViewerContext&quot; } }, { &quot;constraint&quot;: &quot;return&quot;, &quot;inner&quot;: { &quot;constraint&quot;: &quot;extends&quot;, &quot;inner&quot;: {&quot;constraint&quot;: &quot;name&quot;, &quot;pattern&quot;: &quot;Ent&quot;} } } ], &quot;model&quot;: { &quot;modes&quot;: [&quot;add-via-obscure-feature&quot;], &quot;sinks&quot;: [ { &quot;kind&quot;: &quot;Sink&quot;, &quot;port&quot;: &quot;Argument(0)&quot;, &quot;features&quot;: [&quot;via-gen&quot;] } ] } } ] }   ","version":"Next","tagName":"h3"},{"title":"Specification​","type":1,"pageTitle":"Models & Model Generators","url":"/docs/models/#specification","content":" Each JSON file is a JSON object with a key model_generators associated with a list of &quot;rules&quot;.  Each &quot;rule&quot; defines a &quot;filter&quot; (which uses &quot;constraints&quot; to specify methods for which a &quot;model&quot; should be generated) and a &quot;model&quot;. A rule has the following key/values:  find: The type of thing to find. We support methods and fields; where: A list of &quot;constraints&quot;. All constraints must be satisfied by a method or field in order to generate a model for it. All the constraints are listed below, grouped by the type of object they are applied to: Method: signature_match: Expects at least one of the two allowed groups of extra properties: [name | names] [parent | parents | extends [include_self]] where: name (a single string) or names (a list of alternative strings): is exact matched to the method nameparent (a single string) or parents (a list of alternative strings) is exact matched to the class of the method or extends (either a single string or a list of alternative strings) is exact matched to the base classes or interfaces of the method. extends allows an optional property include_self which is a boolean to indicate if the constraint is applied to the class itself or not (defaults to true). signature | signature_pattern: Expects an extra property pattern which is a regex (with appropriate escaping) to fully match the full signature (class, method, argument types) of a method; NOTE: Usage of this constraint is discouraged as it has poor performance. Try using signature_match instead! (Exception: Performance does not suffer if the entire method signature is exactly as specified in pattern. This provides an easy way to match full signatures with parameter and return types) parent: Expects an extra property inner [Type] which contains a nested constraint to apply to the class holding the method;parameter: Expects an extra properties idx and inner [Parameter] or [Type], matches when the idx-th parameter of the function or method matches the nested constraint inner;any_parameter: Expects an optional extra property start_idx and inner [Parameter] or [Type], matches when there is any parameters (starting at start_idx) of the function or method matches the nested constraint inner;return: Expects an extra property inner [Type] which contains a nested constraint to apply to the return of the method;is_static | is_constructor | is_native | has_code: Accepts an extra property value which is either true or false. By default, value is considered true;number_parameters: Expects an extra property inner [Integer] which contains a nested constraint to apply to the number of parameters (counting the implicit this parameter);number_overrides: Expects an extra property inner [Integer] which contains a nested constraint to apply on the number of method overrides. Parameter: parameter_has_annotation: Expects an extra property type and an optional property pattern, respectively a string and a regex fully matching the value of the parameter annotation. Type: extends: Expects an extra property inner [Type] which contains a nested constraint that must apply to one of the base classes or itself. The optional property include_self is a boolean that tells whether the constraint must be applied on the type itself or not (defaults to true);super: Expects an extra property inner [Type] which contains a nested constraint that must apply on the direct superclass;is_class | is_interface: Accepts an extra property value which is either true or false. By default, value is considered true; Field: signature: Expects an extra property pattern which is a regex to fully match the full signature of the field. This is of the form &lt;className&gt;.&lt;fieldName&gt;:&lt;fieldType&gt;;parent: Expects an extra property inner [Type] which contains a nested constraint to apply to the class holding the field;is_static: Accepts an extra property value which is either true or false. By default, value is considered true; Method, Type or Field: name: Expects an extra property pattern which is a regex to fully match the name of the item;has_annotation: Expects an extra property type and an optional property pattern, respectively a string and a regex fully matching the value of the annotation.visibility: Expects an extra property is which is either public, private or protected; (Note this does not apply to Field) Integer: &lt; | &lt;= | == | &gt; | &gt;= | !=: Expects an extra property value which contains an integer that the input integer is compared with. The input is the left hand side. Any (Method, Parameter, Type, Field or Integer): all_of: Expects an extra property inners [Any] which is an array holding nested constraints which must all apply;any_of: Expects an extra property inners [Any] which is an array holding nested constraints where one of them must apply;not: Expects an extra property inner [Any] which contains a nested constraint that should not apply. (Note this is not yet implemented for Fields) model: A model, describing sources/sinks/propagations/etc. For method models sources*: A list of sources, i.e a source flowing out of the method via return value or flowing in via an argument. To specify sources flowing out via an argument, specify it as generations. A source/generation has the following key/values: kind: The source name;port**: The source access path (e.g, &quot;Return&quot; or &quot;Argument(1)&quot;);features*: A list of features/breadcrumbs names;via_type_of*: A list of ports; sinks*: A list of sinks, i.e describing that a parameter of the method flows into a sink. A sink has the following key/values: kind: The sink name;port: The sink access path (e.g, &quot;Return&quot; or &quot;Argument(1)&quot;);features*: A list of features/breadcrumbs names;via_type_of*: A list of ports; propagation*: A list of propagations (also called passthrough) that describe whether a taint on a parameter should result in a taint on the return value or another parameter. A propagation has the following key/values: input: The input access path (e.g, &quot;Argument(1)&quot;);output: The output access path (e.g, &quot;Return&quot; or &quot;Argument(2)&quot;);features*: A list of features/breadcrumbs names; attach_to_sources*: A list of attach-to-sources that describe that all sources flowing out of the method on the given parameter or return value must have the given features. An attach-to-source has the following key/values: port: The access path root (e.g, &quot;Return&quot; or &quot;Argument(1)&quot;);features: A list of features/breadcrumb names; attach_to_sinks*: A list of attach-to-sinks that describe that all sources flowing in the method on the given parameter must have the given features. An attach-to-sink has the following key/values: port: The access path root (e.g, &quot;Argument(1)&quot;);features: A list of features/breadcrumb names; attach_to_propagations*: A list of attach-to-propagations that describe that inferred propagations of sources flowing in or out of a given parameter or return value must have the given features. An attach-to-propagation has the following key/values: port: The access path root (e.g, &quot;Return&quot; or &quot;Argument(1)&quot;);features: A list of features/breadcrumb names; add_features_to_arguments*: A list of add-features-to-arguments that describe that flows that might flow on the given argument must have the given features. An add-features-to-argument has the following key/values: port: The access path root (e.g, &quot;Argument(1)&quot;);features: A list of features/breadcrumb names; modes*: A list of mode names that describe specific behaviors of a method;for_all_parameters: Generate sources/sinks/propagations/attachto* for all parameters of a method that satisfy some constraints. It accepts the following key/values: variable: A symbolic name for the parameter;where: An optional list of [Parameter] or [Type] constraints on the parameter;sources | sinks | propagation: Same as under &quot;model&quot;, but we accept the variable name as a parameter number. verbosity*: A logging level, to help debugging. 1 is the most verbose, 5 is the least. The default verbosity level is 5. For Field models sources*: A list of sources the field should hold. A source has the following key/values: kind: The source name;features*: A list of features/breadcrumbs names; sinks*: A list of sinks the field should hold. A sink has the following key/values: kind: The sink name;features*: A list of features/breadcrumbs names;  In the above bullets,  * denotes optional key/value.** denotes optional key/value. Default is &quot;Return&quot;.  Note, the implicit this parameter for methods has the parameter number 0.  ","version":"Next","tagName":"h3"},{"title":"Development​","type":1,"pageTitle":"Models & Model Generators","url":"/docs/models/#development","content":" When Sources or Sinks don't appear in Results​  This could be because your model generator did not find any method matching your query. You can use the &quot;verbosity&quot;: 1 option in your model generator to check if it matched any method. For instance: { &quot;model_generators&quot;: [ { &quot;find&quot;: &quot;methods&quot;, &quot;where&quot;: /* ... */, &quot;model&quot;: { /* ... */ }, &quot;verbosity&quot;: 1 } ] } When running mariana trench, this should print: INFO Method `...` satisfies all constraints in json model generator ... Make sure that your model generator is actually running. You can use the --verbosity 2 option to check that. Make sure your model generator is specified in configuration/default_generator_config.json. You can also check the output models. Use grep SourceKind models@* to see if your source or sink kind exists. Use grep 'Lcom/example/&lt;class-name&gt;;.&lt;method-name&gt;:' models@* to see if a given method exists in the app.  ","version":"Next","tagName":"h3"}]